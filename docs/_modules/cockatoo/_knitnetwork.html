


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cockatoo._knitnetwork &mdash; Cockatoo 0.1.1.0-alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/jquery.fancybox.min.css" type="text/css" />
  
    <link rel="stylesheet" href="../../_static/glpi.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Cockatoo 0.1.1.0-alpha documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html">
          

          
            
            
            <img src="../../_static/images/glpi.png" class="logo" />
          
          </a>

          
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">COCKATOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cockatoo.html">cockatoo module API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Cockatoo</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>cockatoo._knitnetwork</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for cockatoo._knitnetwork</h1><div class="highlight"><pre>
<span></span><span class="c1"># PYTHON STANDARD LIBRARY IMPORTS ---------------------------------------------</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">radians</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="c1"># DUNDER ----------------------------------------------------------------------</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;KnitNetwork&quot;</span>
<span class="p">]</span>

<span class="c1"># THIRD PARTY MODULE IMPORTS --------------------------------------------------</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="c1"># LOCAL MODULE IMPORTS --------------------------------------------------------</span>
<span class="kn">from</span> <span class="nn">cockatoo._knitnetworkbase</span> <span class="kn">import</span> <span class="n">KnitNetworkBase</span>
<span class="kn">from</span> <span class="nn">cockatoo._knitmappingnetwork</span> <span class="kn">import</span> <span class="n">KnitMappingNetwork</span>
<span class="kn">from</span> <span class="nn">cockatoo._knitdinetwork</span> <span class="kn">import</span> <span class="n">KnitDiNetwork</span>
<span class="kn">from</span> <span class="nn">cockatoo.environment</span> <span class="kn">import</span> <span class="n">RHINOINSIDE</span>
<span class="kn">from</span> <span class="nn">cockatoo.exception</span> <span class="kn">import</span> <span class="n">KnitNetworkError</span>
<span class="kn">from</span> <span class="nn">cockatoo.exception</span> <span class="kn">import</span> <span class="n">KnitNetworkGeometryError</span>
<span class="kn">from</span> <span class="nn">cockatoo.exception</span> <span class="kn">import</span> <span class="n">NoEndNodesError</span>
<span class="kn">from</span> <span class="nn">cockatoo.exception</span> <span class="kn">import</span> <span class="n">NoWeftEdgesError</span>
<span class="kn">from</span> <span class="nn">cockatoo.exception</span> <span class="kn">import</span> <span class="n">MappingNetworkError</span>
<span class="kn">from</span> <span class="nn">cockatoo.utilities</span> <span class="kn">import</span> <span class="n">pairwise</span>

<span class="c1"># RHINO IMPORTS ---------------------------------------------------------------</span>
<span class="k">if</span> <span class="n">RHINOINSIDE</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">rhinoinside</span>
    <span class="n">rhinoinside</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Brep</span> <span class="k">as</span> <span class="n">RhinoBrep</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Curve</span> <span class="k">as</span> <span class="n">RhinoCurve</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Line</span> <span class="k">as</span> <span class="n">RhinoLine</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Interval</span> <span class="k">as</span> <span class="n">RhinoInterval</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Mesh</span> <span class="k">as</span> <span class="n">RhinoMesh</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">NurbsSurface</span> <span class="k">as</span> <span class="n">RhinoNurbsSurface</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Point3d</span> <span class="k">as</span> <span class="n">RhinoPoint3d</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Polyline</span> <span class="k">as</span> <span class="n">RhinoPolyline</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Surface</span> <span class="k">as</span> <span class="n">RhinoSurface</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Vector3d</span> <span class="k">as</span> <span class="n">RhinoVector3d</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Brep</span> <span class="k">as</span> <span class="n">RhinoBrep</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Curve</span> <span class="k">as</span> <span class="n">RhinoCurve</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Line</span> <span class="k">as</span> <span class="n">RhinoLine</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Interval</span> <span class="k">as</span> <span class="n">RhinoInterval</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Mesh</span> <span class="k">as</span> <span class="n">RhinoMesh</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">NurbsSurface</span> <span class="k">as</span> <span class="n">RhinoNurbsSurface</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Point3d</span> <span class="k">as</span> <span class="n">RhinoPoint3d</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Polyline</span> <span class="k">as</span> <span class="n">RhinoPolyline</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Surface</span> <span class="k">as</span> <span class="n">RhinoSurface</span>
    <span class="kn">from</span> <span class="nn">Rhino.Geometry</span> <span class="kn">import</span> <span class="n">Vector3d</span> <span class="k">as</span> <span class="n">RhinoVector3d</span>

<span class="c1"># CLASS DECLARATION -----------------------------------------------------------</span>


<div class="viewcode-block" id="KnitNetwork"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork">[docs]</a><span class="k">class</span> <span class="nc">KnitNetwork</span><span class="p">(</span><span class="n">KnitNetworkBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Datastructure for representing a network (graph) consisting of nodes with</span>
<span class="sd">    special attributes aswell as &#39;warp&#39; edges, &#39;weft&#39; edges and contour edges</span>
<span class="sd">    which are neither &#39;warp&#39; nor &#39;weft&#39;.</span>

<span class="sd">    Used for the automatic generation of knitting patterns based on mesh or</span>
<span class="sd">    NURBS surface geometry.</span>

<span class="sd">    Inherits from :class:`KnitNetworkBase`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The implemented algorithms are strongly based on the paper</span>
<span class="sd">    *Automated Generation of Knit Patterns for Non-developable Surfaces* [1]_.</span>
<span class="sd">    Also see *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">    structures* [2]_.</span>

<span class="sd">    The implementation was further influenced by concepts and ideas presented</span>
<span class="sd">    in the papers *Automatic Machine Knitting of 3D Meshes* [3]_,</span>
<span class="sd">    *Visual Knitting Machine Programming* [4]_ and</span>
<span class="sd">    *A Compiler for 3D Machine Knitting* [5]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Popescu, Mariana et al. *Automated Generation of Knit Patterns</span>
<span class="sd">           for Non-developable Surfaces*</span>

<span class="sd">           See: `Automated Generation of Knit Patterns for Non-developable</span>
<span class="sd">           Surfaces &lt;https://block.arch.ethz.ch/brg/files/</span>
<span class="sd">           POPESCU_DMSP-2017_automated-generation-knit-patterns_1505737906.</span>
<span class="sd">           pdf&gt;`_</span>

<span class="sd">    .. [2] Popescu, Mariana *KnitCrete - Stay-in-place knitted formworks for</span>
<span class="sd">           complex concrete structures*</span>

<span class="sd">           See: `KnitCrete - Stay-in-place knitted formworks for complex</span>
<span class="sd">           concrete structures &lt;https://block.arch.ethz.ch/brg/files/</span>
<span class="sd">           POPESCU_2019_ETHZ_PhD_KnitCrete-Stay-in-place-knitted-fabric-</span>
<span class="sd">           formwork-for-complex-concrete-structures_small_1586266206.pdf&gt;`_</span>

<span class="sd">    .. [3] Narayanan, Vidya; Albaugh, Lea; Hodgins, Jessica; Coros, Stelian;</span>
<span class="sd">           McCann, James *Automatic Machine Knitting of 3D Meshes*</span>

<span class="sd">           See: `Automatic Machine Knitting of 3D Meshes</span>
<span class="sd">           &lt;https://textiles-lab.github.io/publications/2018-autoknit/&gt;`_</span>

<span class="sd">    .. [4] Narayanan, Vidya; Wu, Kui et al. *Visual Knitting Machine</span>
<span class="sd">           Programming*</span>

<span class="sd">           See: `Visual Knitting Machine Programming</span>
<span class="sd">           &lt;https://textiles-lab.github.io/publications/2019-visualknit/&gt;`_</span>

<span class="sd">    .. [5] McCann, James; Albaugh, Lea; Narayanan, Vidya; Grow, April;</span>
<span class="sd">           Matusik, Wojciech; Mankoff, Jen; Hodgins, Jessica</span>
<span class="sd">           *A Compiler for 3D Machine Knitting*</span>

<span class="sd">           See: `A Compiler for 3D Machine Knitting</span>
<span class="sd">           &lt;https://la.disneyresearch.com/publication/machine-knitting-</span>
<span class="sd">           compiler/&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># INITIALIZATION ----------------------------------------------------------</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a KnitNetwork (inherits NetworkX graph) with edges, name,</span>
<span class="sd">        graph attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : input graph</span>
<span class="sd">            Data to initialize graph.  If data=None (default) an empty</span>
<span class="sd">            network is created.  The data can be an edge list, any</span>
<span class="sd">            KnitNetworkBase or NetworkX graph object.</span>

<span class="sd">        name : string, optional (default=&#39;&#39;)</span>
<span class="sd">            An optional name for the graph.</span>

<span class="sd">        attr : keyword arguments, optional (default= no attributes)</span>
<span class="sd">            Attributes to add to graph as key=value pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize using original init method</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KnitNetwork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

        <span class="c1"># also copy the mapping_network attribute if it is already available</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">KnitNetwork</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">mapping_network</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping_network</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mapping_network</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping_network</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="KnitNetwork.create_from_contours"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.create_from_contours">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_from_contours</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">course_height</span><span class="p">,</span>
                             <span class="n">reference_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and initialize a KnitNetwork based on a set of contours, a</span>
<span class="sd">        given course height and an optional reference geometry.</span>
<span class="sd">        The reference geometry is a mesh or surface which should be described</span>
<span class="sd">        by the network. While it is optional, it is **HIGHLY** recommended to</span>
<span class="sd">        provide it!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        contours : :obj:`list` of :class:`Rhino.Geometry.Polyline`</span>
<span class="sd">                   or :class:`Rhino.Geometry.Curve`</span>
<span class="sd">            Ordered contours (i.e. isocurves, isolines) to initialize the</span>
<span class="sd">            KnitNetwork with.</span>

<span class="sd">        course_height : float</span>
<span class="sd">            The course height for sampling the contours.</span>

<span class="sd">        reference_geometry : :class:`Rhino.Geometry.Mesh`</span>
<span class="sd">                             or :class:`Rhino.Geometry.Surface`</span>
<span class="sd">            Optional underlying geometry that this network is based on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        KnitNetwork : KnitNetwork</span>
<span class="sd">            A new, initialized KnitNetwork instance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method will automatically call initialize_position_contour_edges()</span>
<span class="sd">        on the newly created network!</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KnitNetworkGeometryError</span>
<span class="sd">            If a supplied contour is not a valid instance of</span>
<span class="sd">            :obj:`Rhino.Geometry.Polyline` or :obj:`Rhino.Geometry.Curve`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create network</span>
        <span class="n">network</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">reference_geometry</span><span class="o">=</span><span class="n">reference_geometry</span><span class="p">)</span>

        <span class="c1"># assign reference_geometry if present and valid</span>
        <span class="k">if</span> <span class="n">reference_geometry</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_geometry</span><span class="p">,</span> <span class="n">RhinoMesh</span><span class="p">):</span>
                <span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;reference_geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reference_geometry</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_geometry</span><span class="p">,</span> <span class="n">RhinoBrep</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">reference_geometry</span><span class="o">.</span><span class="n">IsSurface</span><span class="p">:</span>
                    <span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;reference_geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RhinoNurbsSurface</span><span class="p">(</span>
                                            <span class="n">reference_geometry</span><span class="o">.</span><span class="n">Surfaces</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_geometry</span><span class="p">,</span> <span class="n">RhinoSurface</span><span class="p">):</span>
                <span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;reference_geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reference_geometry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;reference_geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># divide the contours and fill network with nodes</span>
        <span class="n">nodenum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">crv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">contours</span><span class="p">):</span>
            <span class="c1"># check input</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crv</span><span class="p">,</span> <span class="n">RhinoCurve</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crv</span><span class="p">,</span> <span class="n">RhinoPolyline</span><span class="p">):</span>
                    <span class="n">crv</span> <span class="o">=</span> <span class="n">crv</span><span class="o">.</span><span class="n">ToPolylineCurve</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">errMsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Contour at index </span><span class="si">{}</span><span class="s2"> is not &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span>
                              <span class="s2">&quot;a valid Curve or Polyline!&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">KnitNetworkGeometryError</span><span class="p">(</span><span class="n">errMsg</span><span class="p">)</span>

            <span class="c1"># compute divisioncount and divide contour</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">crv</span><span class="o">.</span><span class="n">GetLength</span><span class="p">()</span> <span class="o">/</span> <span class="n">course_height</span><span class="p">)</span>
            <span class="n">tcrv</span> <span class="o">=</span> <span class="n">crv</span><span class="o">.</span><span class="n">DivideByCount</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">tcrv</span><span class="p">:</span>
                <span class="n">dpts</span> <span class="o">=</span> <span class="p">[</span><span class="n">crv</span><span class="o">.</span><span class="n">PointAtStart</span><span class="p">,</span> <span class="n">crv</span><span class="o">.</span><span class="n">PointAtEnd</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dpts</span> <span class="o">=</span> <span class="p">[</span><span class="n">crv</span><span class="o">.</span><span class="n">PointAt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tcrv</span><span class="p">]</span>

            <span class="c1"># loop over all nodes on the current contour</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dpts</span><span class="p">):</span>
                <span class="c1"># declare node attributes</span>
                <span class="n">vpos</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">vnum</span> <span class="o">=</span> <span class="n">j</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dpts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">vleaf</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vleaf</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># create network node from rhino point</span>
                <span class="n">network</span><span class="o">.</span><span class="n">node_from_point3d</span><span class="p">(</span><span class="n">nodenum</span><span class="p">,</span>
                                          <span class="n">point</span><span class="p">,</span>
                                          <span class="n">position</span><span class="o">=</span><span class="n">vpos</span><span class="p">,</span>
                                          <span class="n">num</span><span class="o">=</span><span class="n">vnum</span><span class="p">,</span>
                                          <span class="n">leaf</span><span class="o">=</span><span class="n">vleaf</span><span class="p">,</span>
                                          <span class="n">start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">segment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">increase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">decrease</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

                <span class="c1"># increment counter</span>
                <span class="n">nodenum</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># call position contour initialization</span>
        <span class="n">network</span><span class="o">.</span><span class="n">initialize_position_contour_edges</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">network</span></div>

    <span class="c1"># TEXTUAL REPRESENTATION OF NETWORK ---------------------------------------</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a textual description of the network.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        description : str</span>
<span class="sd">            A textual description of the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;KnitNetwork&quot;</span>

        <span class="n">nn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">ce</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contour_edges</span><span class="p">)</span>
        <span class="n">wee</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weft_edges</span><span class="p">)</span>
        <span class="n">wae</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">warp_edges</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;(</span><span class="si">{}</span><span class="s2"> Nodes, </span><span class="si">{}</span><span class="s2"> Position Contours, </span><span class="si">{}</span><span class="s2"> Weft, </span><span class="si">{}</span><span class="s2"> Warp)&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">ce</span><span class="p">,</span> <span class="n">wee</span><span class="p">,</span> <span class="n">wae</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="n">data</span>

<div class="viewcode-block" id="KnitNetwork.ToString"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.ToString">[docs]</a>    <span class="k">def</span> <span class="nf">ToString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a textual description of the network.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        description : str</span>
<span class="sd">            A textual description of the network.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Used for overloading the Grasshopper display in data parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="c1"># INITIALIZATION OF POSITION CONTOUR EDGES --------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.initialize_position_contour_edges"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.initialize_position_contour_edges">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_position_contour_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates all initial position contour edges as neither &#39;warp&#39; nor &#39;weft&#39;</span>
<span class="sd">        by iterating over all nodes in the network and grouping them based on</span>
<span class="sd">        their &#39;position&#39; attribute.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is automatically called when creating a KnitNetwork using</span>
<span class="sd">        the create_from_contours method!</span>

<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get all nodes by position</span>
        <span class="n">posList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_nodes_by_position</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">posList</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">create_contour_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span></div>

    <span class="c1"># INITIALIZATION OF &#39;WEFT&#39; EDGES BETWEEN &#39;LEAF&#39; NODES ---------------------</span>

<div class="viewcode-block" id="KnitNetwork.initialize_leaf_connections"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.initialize_leaf_connections">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_leaf_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create all initial connections of the &#39;leaf&#39; nodes by iterating over</span>
<span class="sd">        all position contours and creating &#39;weft&#39; edges between the &#39;leaf&#39;</span>
<span class="sd">        nodes of the position contours.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get all leaves</span>
        <span class="n">leafNodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_leaves_by_position</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># loop through all the positions leaves</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lpos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">leafNodes</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># loop through pairs of leaves</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">leafNodes</span><span class="p">):</span>
                <span class="n">startLeaf</span> <span class="o">=</span> <span class="n">lpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">endLeaf</span> <span class="o">=</span> <span class="n">lpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nextStart</span> <span class="o">=</span> <span class="n">leafNodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nextEnd</span> <span class="o">=</span> <span class="n">leafNodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># add edges to the network</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">startLeaf</span><span class="p">,</span> <span class="n">nextStart</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">endLeaf</span><span class="p">,</span> <span class="n">nextEnd</span><span class="p">)</span></div>

    <span class="c1"># INITIALIZATION OF PRELIMINARY &#39;WEFT&#39; EDGES ------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.attempt_weft_connection"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.attempt_weft_connection">[docs]</a>    <span class="k">def</span> <span class="nf">attempt_weft_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">source_nodes</span><span class="p">,</span>
                                <span class="n">max_connections</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for attempting a &#39;weft&#39; connection to a candidate</span>
<span class="sd">        node based on certain parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : :obj:`tuple`</span>
<span class="sd">            2-tuple representing the source node for the possible &#39;weft&#39; edge.</span>

<span class="sd">        candidate ::obj:`tuple`</span>
<span class="sd">            -tuple representing the target node for the possible &#39;weft&#39; edge.</span>

<span class="sd">        source_nodes : :obj:`list`</span>
<span class="sd">            List of nodes on the position contour of node. Used to check if</span>
<span class="sd">            the candidate node already has a connection.</span>

<span class="sd">        max_connections : int, optional</span>
<span class="sd">            The new &#39;weft&#39; connection will only be made if the candidate nodes</span>
<span class="sd">            number of connected neighbors is below this.</span>

<span class="sd">            Defaults to ``4``.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``True``, this routine and all its subroutines will print</span>
<span class="sd">            messages about what is happening to the console.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the connection has been made,</span>
<span class="sd">            ``False`` otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># define verbose print function</span>
        <span class="n">v_print</span> <span class="o">=</span> <span class="nb">print</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span>

        <span class="c1"># get connected neighbors</span>
        <span class="n">connecting_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># only do something if the maximum is not reached</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connecting_neighbors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_connections</span><span class="p">:</span>
            <span class="c1"># determine if the node is already connected to a node from</span>
            <span class="c1"># the input source nodes</span>
            <span class="n">isConnected</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">connecting_neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">]:</span>
                    <span class="n">isConnected</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Candidate node </span><span class="si">{}</span><span class="s2"> is &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                            <span class="s2">&quot;already connected! &quot;</span> <span class="o">+</span>
                            <span class="s2">&quot;Skipping to next &quot;</span> <span class="o">+</span>
                            <span class="s2">&quot;node...&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="c1"># check the flag and act accordingly</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isConnected</span><span class="p">:</span>
                <span class="c1"># print info on verbose setting</span>
                <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Connecting node </span><span class="si">{}</span><span class="s2"> to best &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                        <span class="s2">&quot;candidate </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="c1"># if all conditions are met, make the &#39;weft&#39; connection</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">_create_initial_weft_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                         <span class="n">contour_set</span><span class="p">,</span>
                                         <span class="n">force_continuous_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">force_continuous_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">max_connections</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                         <span class="n">precise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method for creating initial &#39;weft&#39; connections for the supplied</span>
<span class="sd">        set of contours, starting from the first contour in the set and</span>
<span class="sd">        propagating to the last contour in the set.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># define verbose print function</span>
        <span class="n">v_print</span> <span class="o">=</span> <span class="nb">print</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Not enough contours in contour set!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># print info on verbose output</span>
        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Creating initial &#39;weft&#39; connections for contour set...&quot;</span><span class="p">)</span>

        <span class="c1"># loop over all nodes of positions (list of lists of tuples)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">contour_set</span><span class="p">):</span>
            <span class="c1"># pos is a list of tuples (nodes)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_set</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_set</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c1"># get initial and target nodes without &#39;leaf&#39; nodes</span>
                <span class="n">initial_nodes</span> <span class="o">=</span> <span class="n">contour_set</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">target_nodes</span> <span class="o">=</span> <span class="n">contour_set</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># options for continuous start and end</span>
                <span class="k">if</span> <span class="n">force_continuous_start</span><span class="p">:</span>
                    <span class="n">initial_nodes</span> <span class="o">=</span> <span class="n">initial_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">target_nodes</span> <span class="o">=</span> <span class="n">target_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">force_continuous_end</span><span class="p">:</span>
                    <span class="n">initial_nodes</span> <span class="o">=</span> <span class="n">initial_nodes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">target_nodes</span> <span class="o">=</span> <span class="n">target_nodes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># skip if one of the contours has no nodes</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># define forbidden node index</span>
                <span class="n">forbidden_node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="c1"># loop through all nodes on the current position</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">):</span>
                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Processing node </span><span class="si">{}</span><span class="s2"> on position </span><span class="si">{}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]))</span>

                    <span class="c1"># get the geometry for the current node</span>
                    <span class="n">thisPt</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>

                    <span class="c1"># filtering according to forbidden nodes</span>
                    <span class="n">target_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tn</span> <span class="k">for</span> <span class="n">tn</span> <span class="ow">in</span> <span class="n">target_nodes</span>
                                    <span class="k">if</span> <span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">forbidden_node</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># get four closest nodes on adjacent contour</span>
                    <span class="k">if</span> <span class="n">precise</span><span class="p">:</span>
                        <span class="n">allDists</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisPt</span><span class="o">.</span><span class="n">DistanceTo</span><span class="p">(</span><span class="n">tv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                                    <span class="k">for</span> <span class="n">tv</span> <span class="ow">in</span> <span class="n">target_nodes</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">allDists</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisPt</span><span class="o">.</span><span class="n">DistanceToSquared</span><span class="p">(</span><span class="n">tv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                                    <span class="k">for</span> <span class="n">tv</span> <span class="ow">in</span> <span class="n">target_nodes</span><span class="p">]</span>

                    <span class="c1"># sort the target nodes by distance to current node</span>
                    <span class="n">allDists</span><span class="p">,</span> <span class="n">sorted_target_nodes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                                <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">allDists</span><span class="p">,</span>
                                            <span class="n">target_nodes</span><span class="p">),</span>
                                        <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

                    <span class="c1"># the four closest nodes are the possible connections</span>
                    <span class="n">possible_connections</span> <span class="o">=</span> <span class="n">sorted_target_nodes</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Possible connections: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">pc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">possible_connections</span><span class="p">]))</span>

                    <span class="c1"># handle edge case where there is no possible</span>
                    <span class="c1"># connection or just one</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># skip if there are no possible connections</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># attempt to connect to only possible candidate</span>
                        <span class="n">fCand</span> <span class="o">=</span> <span class="n">possible_connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_weft_connection</span><span class="p">(</span>
                                            <span class="n">node</span><span class="p">,</span>
                                            <span class="n">fCand</span><span class="p">,</span>
                                            <span class="n">initial_nodes</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                        <span class="c1"># set forbidden node</span>
                        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                            <span class="n">forbidden_node</span> <span class="o">=</span> <span class="n">fCand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">continue</span>

                    <span class="c1"># get the contours current direction</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">contourDir</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                                    <span class="n">thisPt</span><span class="p">,</span>
                                    <span class="n">initial_nodes</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">Direction</span>
                    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">contourDir</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                                <span class="n">initial_nodes</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">],</span> <span class="n">thisPt</span><span class="p">)</span><span class="o">.</span><span class="n">Direction</span>
                    <span class="n">contourDir</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>

                    <span class="c1"># get the directions of the possible connections</span>
                    <span class="n">candidatePoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>
                                       <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">possible_connections</span><span class="p">]</span>
                    <span class="n">candidateDirections</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoLine</span><span class="p">(</span>
                            <span class="n">thisPt</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">Direction</span> <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">candidatePoints</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">cd</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">candidateDirections</span><span class="p">]</span>

                    <span class="c1"># get the angles between contour dir and possible conn dir</span>
                    <span class="n">normals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">CrossProduct</span><span class="p">(</span>
                                <span class="n">contourDir</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">candidateDirections</span><span class="p">]</span>
                    <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">VectorAngle</span><span class="p">(</span>
                              <span class="n">contourDir</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">cd</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                              <span class="n">candidateDirections</span><span class="p">,</span> <span class="n">normals</span><span class="p">)]</span>

                    <span class="c1"># compute deltas as a mesaure of perpendicularity</span>
                    <span class="n">deltas</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>

                    <span class="c1"># sort possible connections by distance, then by delta</span>
                    <span class="n">allDists</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">most_perpendicular</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                            <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                                    <span class="n">allDists</span><span class="p">,</span>
                                    <span class="n">deltas</span><span class="p">,</span>
                                    <span class="n">angles</span><span class="p">,</span>
                                    <span class="n">possible_connections</span><span class="p">[:]),</span>
                                    <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

                    <span class="c1"># get node neighbors</span>
                    <span class="n">nNeighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                    <span class="c1"># compute angle difference</span>
                    <span class="n">aDelta</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                    <span class="c1"># CONNECTION FOR LEAST ANGLE CHANGE -----------------------</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nNeighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">aDelta</span> <span class="o">&lt;</span> <span class="n">radians</span><span class="p">(</span><span class="mf">6.0</span><span class="p">):</span>
                        <span class="c1"># print info on verbose setting</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Using procedure for least angle &quot;</span> <span class="o">+</span>
                                <span class="s2">&quot;change connection...&quot;</span><span class="p">)</span>

                        <span class="c1"># get previous connected edge and its direction</span>
                        <span class="n">prevEdges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weft_edges</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prevEdges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">KnitNetworkError</span><span class="p">(</span>
                                <span class="s2">&quot;More than one previous &#39;weft&#39; connection! &quot;</span> <span class="o">+</span>
                                <span class="s2">&quot;This was unexpeced...&quot;</span><span class="p">)</span>
                            <span class="n">prevDir</span> <span class="o">=</span> <span class="n">prevEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">Direction</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">prevDir</span> <span class="o">=</span> <span class="n">prevEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">Direction</span>
                        <span class="n">prevDir</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>

                        <span class="c1"># get directions for the best two candidates</span>
                        <span class="n">mpA</span> <span class="o">=</span> <span class="n">most_perpendicular</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">mpB</span> <span class="o">=</span> <span class="n">most_perpendicular</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">dirA</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span><span class="n">thisPt</span><span class="p">,</span> <span class="n">mpA</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">Direction</span>
                        <span class="n">dirB</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span><span class="n">thisPt</span><span class="p">,</span> <span class="n">mpB</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">Direction</span>
                        <span class="n">dirA</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>
                        <span class="n">dirB</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>

                        <span class="c1"># get normals for angle measurement</span>
                        <span class="n">normalA</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">prevDir</span><span class="p">,</span> <span class="n">dirA</span><span class="p">)</span>
                        <span class="n">normalB</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">prevDir</span><span class="p">,</span> <span class="n">dirB</span><span class="p">)</span>

                        <span class="c1"># measure the angles</span>
                        <span class="n">angleA</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">VectorAngle</span><span class="p">(</span>
                                                        <span class="n">prevDir</span><span class="p">,</span>
                                                        <span class="n">dirA</span><span class="p">,</span>
                                                        <span class="n">normalA</span><span class="p">)</span>
                        <span class="n">angleB</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">VectorAngle</span><span class="p">(</span>
                                                        <span class="n">prevDir</span><span class="p">,</span>
                                                        <span class="n">dirB</span><span class="p">,</span>
                                                        <span class="n">normalB</span><span class="p">)</span>

                        <span class="c1"># select final candidate for connection by angle</span>
                        <span class="k">if</span> <span class="n">angleA</span> <span class="o">&lt;</span> <span class="n">angleB</span><span class="p">:</span>
                            <span class="n">fCand</span> <span class="o">=</span> <span class="n">mpA</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">fCand</span> <span class="o">=</span> <span class="n">mpB</span>

                        <span class="c1"># attempt to connect to final candidate</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_weft_connection</span><span class="p">(</span>
                                            <span class="n">node</span><span class="p">,</span>
                                            <span class="n">fCand</span><span class="p">,</span>
                                            <span class="n">initial_nodes</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                        <span class="c1"># set forbidden node for next pass</span>
                        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                            <span class="n">forbidden_node</span> <span class="o">=</span> <span class="n">fCand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># CONNECTION FOR MOST PERPENDICULAR --------------------</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># print info on verbose setting</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Using procedure for most &quot;</span> <span class="o">+</span>
                                <span class="s2">&quot;perpendicular connection...&quot;</span><span class="p">)</span>
                        <span class="c1"># define final candidate</span>
                        <span class="n">fCand</span> <span class="o">=</span> <span class="n">most_perpendicular</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># attempt to connect to final candidate node</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_weft_connection</span><span class="p">(</span>
                                            <span class="n">node</span><span class="p">,</span>
                                            <span class="n">fCand</span><span class="p">,</span>
                                            <span class="n">initial_nodes</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                        <span class="c1"># set forbidden node if connection has been made</span>
                        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                            <span class="n">forbidden_node</span> <span class="o">=</span> <span class="n">fCand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_create_second_pass_weft_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                             <span class="n">contour_set</span><span class="p">,</span>
                                             <span class="n">include_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">least_connected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">precise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method for creating second pass &#39;weft&#39; connections for the</span>
<span class="sd">        given set of contours.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">v_print</span> <span class="o">=</span> <span class="nb">print</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span>

        <span class="c1"># get attributes only once</span>
        <span class="n">position_attributes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">)</span>
        <span class="n">num_attributes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;num&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Not enough contours in contour set!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># print info on verbose output</span>
        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Creating second pass &#39;weft&#39; connections for contour set...&quot;</span><span class="p">)</span>

        <span class="c1"># loop over all nodes of positions (list of lists of tuples)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">contour_set</span><span class="p">):</span>

            <span class="c1"># get initial nodes</span>
            <span class="n">initial_nodes</span> <span class="o">=</span> <span class="n">contour_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># get target position candidates</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_set</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span>
                    <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_set</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">target_positionA</span> <span class="o">=</span> <span class="n">contour_set</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]</span>
                <span class="n">target_positionB</span> <span class="o">=</span> <span class="n">contour_set</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">target_positionA</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">target_positionB</span> <span class="o">=</span> <span class="n">contour_set</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_set</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">target_positionA</span> <span class="o">=</span> <span class="n">contour_set</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]</span>
                <span class="n">target_positionB</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># loop through all nodes on current position</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">):</span>
                <span class="c1"># print info on verbose setting</span>
                <span class="n">v_print</span><span class="p">(</span>
                    <span class="s2">&quot;Processing node </span><span class="si">{}</span><span class="s2"> on position </span><span class="si">{}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]))</span>

                <span class="c1"># get connecting edges on target position</span>
                <span class="n">conWeftEdges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weft_edges</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">conPos</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conWeftEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;No previously connected weft edges...&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">weftEdge</span> <span class="ow">in</span> <span class="n">conWeftEdges</span><span class="p">:</span>
                    <span class="n">weftEdgeFrom</span> <span class="o">=</span> <span class="n">weftEdge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">weftEdgeTo</span> <span class="o">=</span> <span class="n">weftEdge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">weftEdgeFrom</span> <span class="o">!=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">posEdgeTarget</span> <span class="o">=</span> <span class="n">position_attributes</span><span class="p">[</span><span class="n">weftEdgeFrom</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">weftEdgeTo</span> <span class="o">!=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">posEdgeTarget</span> <span class="o">=</span> <span class="n">position_attributes</span><span class="p">[</span><span class="n">weftEdgeTo</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">posEdgeTarget</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">:</span>
                        <span class="n">conPos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">posEdgeTarget</span><span class="p">)</span>

                <span class="c1"># select target position and continue in edge case scenarios</span>
                <span class="n">target_positions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">target_positionA</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">target_positionB</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">:</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Node is connected. Skipping...&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">target_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_positionB</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">target_positionB</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">target_positionA</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">:</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Node is connected. Skipping...&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">target_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_positionA</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">((</span><span class="n">target_positionA</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">)</span> <span class="ow">and</span>
                      <span class="p">(</span><span class="n">target_positionB</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">)):</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Node is connected. Skipping...&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="p">((</span><span class="n">target_positionB</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">)</span> <span class="ow">and</span>
                      <span class="p">(</span><span class="n">target_positionA</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">)):</span>
                    <span class="n">target_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_positionA</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">((</span><span class="n">target_positionA</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">)</span> <span class="ow">and</span>
                      <span class="p">(</span><span class="n">target_positionB</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conPos</span><span class="p">)):</span>
                    <span class="n">target_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_positionB</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">target_positionA</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span>
                      <span class="n">target_positionB</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">conPos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">target_positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_positionA</span><span class="p">,</span> <span class="n">target_positionB</span><span class="p">]</span>

                <span class="c1"># print info on verbose setting</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Two target positions: </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                         <span class="o">*</span><span class="n">target_positions</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Target position: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

                <span class="c1"># skip if there are no target positions</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;No target position! Skipping...&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># only proceed if there is a target position</span>
                <span class="k">for</span> <span class="n">target_position</span> <span class="ow">in</span> <span class="n">target_positions</span><span class="p">:</span>
                    <span class="c1"># get target nodes</span>
                    <span class="n">target_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_on_position</span><span class="p">(</span>
                                                    <span class="n">target_position</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># get the point geo of this node</span>
                    <span class="n">thisPt</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>

                    <span class="c1"># get a window of possible connections on the target</span>
                    <span class="c1"># position by looking for the previos node on this contour</span>
                    <span class="c1"># connected to target position, then propagating along</span>
                    <span class="c1"># the target position to the next node that is connected</span>
                    <span class="c1"># to this position. these two nodes will define the window</span>

                    <span class="c1"># NOTE: the current node should never have a connection</span>
                    <span class="c1"># to target position (theoretically!), otherwise it should</span>
                    <span class="c1"># have fallen through the checks by now</span>

                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Target position is </span><span class="si">{}</span><span class="s2">. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_position</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s2">&quot;Computing window...&quot;</span><span class="p">)</span>

                    <span class="c1"># get the previous node on this contour</span>
                    <span class="n">prevNode</span> <span class="o">=</span> <span class="n">initial_nodes</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="c1"># assume that the previous node has a connection</span>
                    <span class="n">prevCon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weft_edges</span><span class="p">(</span><span class="n">prevNode</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># get possible connections from previous connection</span>
                    <span class="n">possible_connections</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">prevCon</span><span class="p">:</span>
                        <span class="n">edgeFrom</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">edgeTo</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">edgeFrom</span> <span class="o">!=</span> <span class="n">prevNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">prevNodeTargetPos</span> <span class="o">=</span> <span class="n">position_attributes</span><span class="p">[</span><span class="n">edgeFrom</span><span class="p">]</span>
                            <span class="n">prevNodeTargetIndex</span> <span class="o">=</span> <span class="n">num_attributes</span><span class="p">[</span><span class="n">edgeFrom</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">edgeTo</span> <span class="o">!=</span> <span class="n">prevNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">prevNodeTargetPos</span> <span class="o">=</span> <span class="n">position_attributes</span><span class="p">[</span><span class="n">edgeTo</span><span class="p">]</span>
                            <span class="n">prevNodeTargetIndex</span> <span class="o">=</span> <span class="n">num_attributes</span><span class="p">[</span><span class="n">edgeTo</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">prevNodeTargetPos</span> <span class="o">==</span> <span class="n">target_position</span><span class="p">:</span>
                            <span class="n">possible_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                           <span class="n">target_nodes</span><span class="p">[</span><span class="n">prevNodeTargetIndex</span><span class="p">])</span>

                    <span class="c1"># the farthest connection of the previous node is the first</span>
                    <span class="c1"># point for our window</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_connections</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">possible_connections</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;num&quot;</span><span class="p">])</span>
                        <span class="n">possible_connections</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                        <span class="n">start_of_window</span> <span class="o">=</span> <span class="n">possible_connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">start_of_window</span> <span class="o">=</span> <span class="n">possible_connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># print info on verbose setting</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;No possible connection, skipping...&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1"># get the next node on this pos that is</span>
                    <span class="c1"># connected to target position</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">future_nodes</span> <span class="o">=</span> <span class="n">initial_nodes</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="k">for</span> <span class="n">futurenode</span> <span class="ow">in</span> <span class="n">future_nodes</span><span class="p">:</span>
                            <span class="n">filteredWeftEdges</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">futureWeftEdges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weft_edges</span><span class="p">(</span>
                                                <span class="n">futurenode</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">futureweft</span> <span class="ow">in</span> <span class="n">futureWeftEdges</span><span class="p">:</span>
                                <span class="n">fwn</span> <span class="o">=</span> <span class="p">(</span><span class="n">futureweft</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">futureweft</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                                <span class="n">fwn_pos</span> <span class="o">=</span> <span class="n">fwn</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]</span>
                                <span class="n">fwn_num</span> <span class="o">=</span> <span class="n">fwn</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;num&quot;</span><span class="p">]</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">fwn_pos</span> <span class="o">==</span> <span class="n">target_position</span> <span class="ow">and</span>
                                        <span class="n">fwn_num</span> <span class="o">==</span> <span class="n">start_of_window</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;num&quot;</span><span class="p">]):</span>
                                    <span class="c1"># if the start of the window is found,</span>
                                    <span class="c1"># it is the only possible connection</span>
                                    <span class="n">filteredWeftEdges</span> <span class="o">=</span> <span class="p">[</span><span class="n">futureweft</span><span class="p">]</span>
                                    <span class="k">break</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">fwn_pos</span> <span class="o">==</span> <span class="n">target_position</span> <span class="ow">and</span>
                                        <span class="n">fwn_num</span> <span class="o">&gt;</span> <span class="n">start_of_window</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;num&quot;</span><span class="p">]):</span>
                                    <span class="n">filteredWeftEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">futureweft</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">continue</span>
                            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">filteredWeftEdges</span> <span class="ow">or</span>
                                    <span class="nb">len</span><span class="p">(</span><span class="n">filteredWeftEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="n">end_of_window</span> <span class="o">=</span> <span class="kc">None</span>
                                <span class="k">continue</span>

                            <span class="c1"># sort the filtered weft edges based on the &#39;num&#39;</span>
                            <span class="c1"># attribute of their target node</span>
                            <span class="n">filteredWeftEdges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;num&quot;</span><span class="p">])</span>

                            <span class="c1"># get the end of the window from the first edge on</span>
                            <span class="c1"># the target position</span>
                            <span class="n">end_of_window</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="n">filteredWeftEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">filteredWeftEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>

                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">end_of_window</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="c1"># define the window</span>
                    <span class="k">if</span> <span class="n">end_of_window</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">window</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_of_window</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">end_of_window</span> <span class="o">==</span> <span class="n">start_of_window</span><span class="p">:</span>
                        <span class="n">window</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_of_window</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">window</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span>
                                  <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                  <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">start_of_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                  <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">end_of_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># print info on verbose setting</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Length of window is 0, skipping...&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># print info on verbose setting</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Window has only one node.&quot;</span><span class="p">)</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Connecting to node </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                                <span class="s2">&quot; on position </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                    <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]))</span>

                        <span class="c1"># connect weft edge</span>
                        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># print info on verbose setting</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Processing window nodes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                    <span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]))</span>

                        <span class="c1"># sort nodes in window by distance</span>
                        <span class="k">if</span> <span class="n">precise</span><span class="p">:</span>
                            <span class="n">allDists</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisPt</span><span class="o">.</span><span class="n">DistanceTo</span><span class="p">(</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                                        <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">allDists</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisPt</span><span class="o">.</span><span class="n">DistanceToSquared</span><span class="p">(</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                                        <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]</span>
                        <span class="n">allDists</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">allDists</span><span class="p">,</span> <span class="n">window</span><span class="p">),</span>
                                               <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

                        <span class="k">if</span> <span class="n">least_connected</span><span class="p">:</span>
                            <span class="n">wn_count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]</span>
                            <span class="n">wn_count</span><span class="p">,</span> <span class="n">allDists</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                                    <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">allDists</span><span class="p">,</span> <span class="n">wn_count</span><span class="p">,</span> <span class="n">window</span><span class="p">),</span>
                                            <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                            <span class="c1"># set final candidate node</span>
                            <span class="n">fCand</span> <span class="o">=</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># get the contours current direction</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">contourDir</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                                        <span class="n">thisPt</span><span class="p">,</span>
                                        <span class="n">initial_nodes</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">Direction</span>
                            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">contourDir</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                                        <span class="n">initial_nodes</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">],</span>
                                        <span class="n">thisPt</span><span class="p">)</span><span class="o">.</span><span class="n">Direction</span>
                            <span class="n">contourDir</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>

                            <span class="c1"># get the directions of the possible connections</span>
                            <span class="n">candidatePoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>
                                               <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]</span>
                            <span class="n">candidateDirections</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">RhinoLine</span><span class="p">(</span><span class="n">thisPt</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">Direction</span>
                                <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">candidatePoints</span><span class="p">]</span>
                            <span class="p">[</span><span class="n">cd</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">candidateDirections</span><span class="p">]</span>

                            <span class="c1"># get the angles between contour dir and window dir</span>
                            <span class="n">normals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">CrossProduct</span><span class="p">(</span>
                                       <span class="n">contourDir</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">candidateDirections</span><span class="p">]</span>
                            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">VectorAngle</span><span class="p">(</span>
                                      <span class="n">contourDir</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">cd</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                                                <span class="n">candidateDirections</span><span class="p">,</span> <span class="n">normals</span><span class="p">)]</span>

                            <span class="c1"># compute deltas as a mesaure of perpendicularity</span>
                            <span class="n">deltas</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>

                            <span class="c1"># sort window by distance, then by delta</span>
                            <span class="n">allDists</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">most_perpendicular</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span>
                                        <span class="nb">zip</span><span class="p">(</span><span class="n">allDists</span><span class="p">,</span>
                                            <span class="n">deltas</span><span class="p">,</span>
                                            <span class="n">window</span><span class="p">),</span>
                                        <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                            <span class="c1"># set final candidate node for connection</span>
                            <span class="n">fCand</span> <span class="o">=</span> <span class="n">most_perpendicular</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># print info on verbose setting</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Connecting to node &quot;</span> <span class="o">+</span>
                                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> on position </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                        <span class="n">fCand</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                        <span class="n">fCand</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]))</span>

                        <span class="c1"># connect weft edge to best target</span>
                        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">fCand</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;position&quot;</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">fCand</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">fCand</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

<div class="viewcode-block" id="KnitNetwork.initialize_weft_edges"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.initialize_weft_edges">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_weft_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">start_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">propagate_from_center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">force_continuous_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">force_continuous_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">angle_threshold</span><span class="o">=</span><span class="n">radians</span><span class="p">(</span><span class="mf">6.0</span><span class="p">),</span>
                              <span class="n">max_connections</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                              <span class="n">least_connected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">precise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to create all the preliminary &#39;weft&#39; connections for the</span>
<span class="sd">        network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_index : int, optional</span>
<span class="sd">            This value defines at which index the list of contours is split.</span>
<span class="sd">            If no index is supplied, will split the list at the longest</span>
<span class="sd">            contour.</span>

<span class="sd">            Defaults to ``None``.</span>

<span class="sd">        propagate_from_center : bool, optional</span>
<span class="sd">            If ``True``, will propagate left and right set of contours from</span>
<span class="sd">            the center contour defined by start_index or the longest contour</span>
<span class="sd">            ( &lt; | &gt; ). Otherwise, the propagation of the contours left to the</span>
<span class="sd">            center will start at the left boundary ( &gt; | &gt; ).</span>

<span class="sd">            Defaults to ``False``</span>

<span class="sd">        force_continuous_start : bool, optional</span>
<span class="sd">            If ``True``, forces the first row of stitches to be continuous.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        force_continuous_end : bool, optional</span>
<span class="sd">            If ``True``, forces the last row of stitches to be continuous.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        max_connections : int, optional</span>
<span class="sd">            The maximum connections a node is allowed to have to be considered</span>
<span class="sd">            for an additional &#39;weft&#39; connection.</span>

<span class="sd">            Defaults to ``4``.</span>

<span class="sd">        least_connected : bool, optional</span>
<span class="sd">            If ``True``, uses the least connected node from the found</span>
<span class="sd">            candidates.</span>

<span class="sd">            Defaults to ``False``</span>

<span class="sd">        precise : bool, optional</span>
<span class="sd">            If ``True``, the distance between nodes will be calculated using</span>
<span class="sd">            the Rhino.Geometry.Point3d.DistanceTo method, otherwise the much</span>
<span class="sd">            faster Rhino.Geometry.Point3d.DistanceToSquared method is used.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``True``, this routine and all its subroutines will print</span>
<span class="sd">            messages about what is happening to the console. Great for</span>
<span class="sd">            debugging and analysis.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KnitNetworkError</span>
<span class="sd">            If the supplied splitting index is too high.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get all the positions / contours</span>
        <span class="n">AllPositions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_nodes_by_position</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_index</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get index of longest contour</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">longest_position_contour</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">start_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AllPositions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">KnitNetworkError</span><span class="p">(</span><span class="s2">&quot;Supplied splitting index is too high!&quot;</span><span class="p">)</span>

        <span class="c1"># if continuous start is True, connect the whole first row</span>
        <span class="k">if</span> <span class="n">force_continuous_start</span><span class="p">:</span>
            <span class="n">chain</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">AllPositions</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairwise</span><span class="p">(</span><span class="n">chain</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># if continuous end is True, connect the whole last row</span>
        <span class="k">if</span> <span class="n">force_continuous_end</span><span class="p">:</span>
            <span class="n">chain</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">AllPositions</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairwise</span><span class="p">(</span><span class="n">chain</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># split position list into two sets based on start index</span>
        <span class="n">leftContours</span> <span class="o">=</span> <span class="n">AllPositions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">start_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># optional propagation from center</span>
        <span class="c1"># NOTE: this has shown problems / weird stitch geometries</span>
        <span class="k">if</span> <span class="n">propagate_from_center</span><span class="p">:</span>
            <span class="n">leftContours</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">rightContours</span> <span class="o">=</span> <span class="n">AllPositions</span><span class="p">[</span><span class="n">start_index</span><span class="p">:]</span>

        <span class="c1"># create the initial weft connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_initial_weft_connections</span><span class="p">(</span>
                            <span class="n">leftContours</span><span class="p">,</span>
                            <span class="n">force_continuous_start</span><span class="o">=</span><span class="n">force_continuous_start</span><span class="p">,</span>
                            <span class="n">force_continuous_end</span><span class="o">=</span><span class="n">force_continuous_end</span><span class="p">,</span>
                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                            <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_create_initial_weft_connections</span><span class="p">(</span>
                            <span class="n">rightContours</span><span class="p">,</span>
                            <span class="n">force_continuous_start</span><span class="o">=</span><span class="n">force_continuous_start</span><span class="p">,</span>
                            <span class="n">force_continuous_end</span><span class="o">=</span><span class="n">force_continuous_end</span><span class="p">,</span>
                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                            <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># create second pass weft connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_second_pass_weft_connections</span><span class="p">(</span>
                                            <span class="n">leftContours</span><span class="p">,</span>
                                            <span class="n">least_connected</span><span class="p">,</span>
                                            <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_create_second_pass_weft_connections</span><span class="p">(</span>
                                            <span class="n">rightContours</span><span class="p">,</span>
                                            <span class="n">least_connected</span><span class="p">,</span>
                                            <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="c1"># INITIALIZATION OF PRELIMINARY &#39;WARP&#39; EDGES ------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.initialize_warp_edges"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.initialize_warp_edges">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_warp_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contour_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for initializing first &#39;warp&#39; connections once all preliminary</span>
<span class="sd">        &#39;weft&#39; connections are made.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        contour_set : :obj:`list`, optional</span>
<span class="sd">            List of lists of nodes to initialize &#39;warp&#39; edges. If none are</span>
<span class="sd">            supplied, all nodes ordered by thei &#39;position&#39; attributes are</span>
<span class="sd">            used.</span>

<span class="sd">            Defaults to ``None``.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``True``, will print verbose output to the console.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if no contour set is provided, use all contours of this network</span>
        <span class="k">if</span> <span class="n">contour_set</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">contour_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_nodes_by_position</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># loop through all positions in the set of contours</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">contour_set</span><span class="p">):</span>
            <span class="c1"># get all nodes on current contour</span>
            <span class="n">initial_nodes</span> <span class="o">=</span> <span class="n">contour_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># loop through all nodes on this contour</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">):</span>
                <span class="n">connected_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">numweft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_weft_edges</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">connected_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">numweft</span> <span class="o">&gt;</span> <span class="mi">2</span>
                        <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_set</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># set &#39;end&#39; attribute for this node</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># loop through all candidate edges</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">connected_edges</span><span class="p">):</span>
                        <span class="c1"># if it&#39;s not a &#39;weft&#39; edge, assign attributes</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;weft&quot;</span><span class="p">]:</span>
                            <span class="n">connected_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="c1"># set &#39;end&#39; attribute to conneted node</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">connected_node</span><span class="p">][</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="c1"># set &#39;warp&#39; attribute to current edge</span>
                            <span class="bp">self</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;warp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="c1"># ASSIGNING OF &#39;SEGMENT&#39; ATTRIBUTES FOR MAPPING NETWORK -------------------</span>

    <span class="k">def</span> <span class="nf">_traverse_weft_edge_until_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_end_node</span><span class="p">,</span> <span class="n">start_node</span><span class="p">,</span>
                                      <span class="n">seen_segments</span><span class="p">,</span> <span class="n">way_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">way_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method for traversing a path of &#39;weft&#39; edges until another</span>
<span class="sd">        &#39;end&#39; node is discoverd.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize output lists</span>
        <span class="k">if</span> <span class="n">way_nodes</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">way_nodes</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
            <span class="n">way_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">way_edges</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">way_edges</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">end_nodes</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="c1"># get the connected edges and filter them, sort out the ones that</span>
        <span class="c1"># already have a &#39;segment&#39; attribute assigned</span>
        <span class="n">connected_weft_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weft_edges</span><span class="p">(</span><span class="n">start_node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">filtered_weft_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cwe</span> <span class="ow">in</span> <span class="n">connected_weft_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cwe</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">cwe</span> <span class="ow">in</span> <span class="n">way_edges</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">cwe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cwe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cwe</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="ow">in</span> <span class="n">way_edges</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">filtered_weft_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cwe</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_weft_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">filtered_weft_edges</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;More than one filtered candidate weft edge! &quot;</span> <span class="o">+</span>
                  <span class="s2">&quot;Segment complete...?&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_weft_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fwec</span> <span class="o">=</span> <span class="n">filtered_weft_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">fwec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">fwec</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># if the connected node is an end node, the segment is finished</span>
            <span class="k">if</span> <span class="n">connected_node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end&quot;</span><span class="p">]:</span>
                <span class="c1"># find out which order to set segment attributes</span>
                <span class="k">if</span> <span class="n">start_end_node</span> <span class="o">&gt;</span> <span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">segStart</span> <span class="o">=</span> <span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">segEnd</span> <span class="o">=</span> <span class="n">start_end_node</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">segStart</span> <span class="o">=</span> <span class="n">start_end_node</span>
                    <span class="n">segEnd</span> <span class="o">=</span> <span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">segStart</span><span class="p">,</span> <span class="n">segEnd</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen_segments</span><span class="p">:</span>
                    <span class="n">segIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seen_segments</span>
                                    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="p">(</span><span class="n">segStart</span><span class="p">,</span> <span class="n">segEnd</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">segIndex</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># append the relevant data to the lists</span>
                <span class="n">end_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">way_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fwec</span><span class="p">)</span>
                <span class="n">seen_segments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segStart</span><span class="p">,</span> <span class="n">segEnd</span><span class="p">))</span>
                <span class="c1"># set final &#39;segment&#39; attributes to all the way nodes</span>
                <span class="k">for</span> <span class="n">waynode</span> <span class="ow">in</span> <span class="n">way_nodes</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">waynode</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">segStart</span><span class="p">,</span>
                                                     <span class="n">segEnd</span><span class="p">,</span>
                                                     <span class="n">segIndex</span><span class="p">)</span>
                <span class="c1"># set final &#39;segment&#39; attributes to all the way edges</span>
                <span class="k">for</span> <span class="n">wayedge</span> <span class="ow">in</span> <span class="n">way_edges</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">wayedge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">wayedge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">segStart</span><span class="p">,</span>
                                                               <span class="n">segEnd</span><span class="p">,</span>
                                                               <span class="n">segIndex</span><span class="p">)</span>
                <span class="c1"># return the seen segments</span>
                <span class="k">return</span> <span class="n">seen_segments</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set the initial segment attribute to the node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_end_node</span><span class="p">,</span>
                                                           <span class="kc">None</span><span class="p">,</span>
                                                           <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># set the initial segment attribute to the edge</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">fwec</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">fwec</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_end_node</span><span class="p">,</span>
                                                     <span class="kc">None</span><span class="p">,</span>
                                                     <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># append the relevant data to the lists</span>
                <span class="n">way_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">way_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fwec</span><span class="p">)</span>

                <span class="c1"># call this method recursively until a &#39;end&#39; node is found</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_weft_edge_until_end</span><span class="p">(</span>
                                                    <span class="n">start_end_node</span><span class="p">,</span>
                                                    <span class="n">connected_node</span><span class="p">,</span>
                                                    <span class="n">seen_segments</span><span class="p">,</span>
                                                    <span class="n">way_nodes</span><span class="p">,</span>
                                                    <span class="n">way_edges</span><span class="p">,</span>
                                                    <span class="n">end_nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seen_segments</span>

<div class="viewcode-block" id="KnitNetwork.traverse_weft_edges_and_set_attributes"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.traverse_weft_edges_and_set_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">traverse_weft_edges_and_set_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_end_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Traverse a path of &#39;weft&#39; edges starting from an &#39;end&#39; node until</span>
<span class="sd">        another &#39;end&#39; node is discovered. Set &#39;segment&#39; attributes to nodes</span>
<span class="sd">        and edges along the way.</span>

<span class="sd">        start_end_node : :obj:`tuple`</span>
<span class="sd">            2-tuple representing the node to start the traversal.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get connected weft edges and sort them by their connected node</span>
        <span class="n">weft_connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weft_edges</span><span class="p">(</span><span class="n">start_end_node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">weft_connections</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># loop through all connected weft edges</span>
        <span class="n">seen_segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cwe</span> <span class="ow">in</span> <span class="n">weft_connections</span><span class="p">:</span>
            <span class="c1"># check if connected weft edge already has a segment attribute</span>
            <span class="k">if</span> <span class="n">cwe</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># get connected node</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">cwe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cwe</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># check the connected node. if it is an end node, we are done</span>
            <span class="k">if</span> <span class="n">connected_node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end&quot;</span><span class="p">]:</span>
                <span class="c1"># get segment start and end</span>
                <span class="k">if</span> <span class="n">start_end_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">segStart</span> <span class="o">=</span> <span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">segEnd</span> <span class="o">=</span> <span class="n">start_end_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">segStart</span> <span class="o">=</span> <span class="n">start_end_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">segEnd</span> <span class="o">=</span> <span class="n">connected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># get segment index</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">segStart</span><span class="p">,</span> <span class="n">segEnd</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen_segments</span><span class="p">:</span>
                    <span class="n">segIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seen_segments</span>
                                    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="p">(</span><span class="n">segStart</span><span class="p">,</span> <span class="n">segEnd</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">segIndex</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># set the final segment attribute to the edge</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">cwe</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">cwe</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">segStart</span><span class="p">,</span> <span class="n">segEnd</span><span class="p">,</span> <span class="n">segIndex</span><span class="p">)</span>
                <span class="n">seen_segments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segStart</span><span class="p">,</span> <span class="n">segEnd</span><span class="p">))</span>

            <span class="c1"># if the connected node is not an end node, we need to travel</span>
            <span class="c1"># until we find one</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seen_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_weft_edge_until_end</span><span class="p">(</span>
                                                        <span class="n">start_end_node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                        <span class="n">connected_node</span><span class="p">,</span>
                                                        <span class="n">seen_segments</span><span class="p">,</span>
                                                        <span class="n">way_edges</span><span class="o">=</span><span class="p">[</span><span class="n">cwe</span><span class="p">])</span></div>

<div class="viewcode-block" id="KnitNetwork.assign_segment_attributes"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.assign_segment_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">assign_segment_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the segmentation for loop generation and assign &#39;segment&#39;</span>
<span class="sd">        attributes to &#39;weft&#39; edges and nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weft_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">errMsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;No &#39;weft&#39; edges in KnitNetwork! Segmentation &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;is impossible.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NoWeftEdgesError</span><span class="p">(</span><span class="n">errMsg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">errMsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;No &#39;end&#39; nodes in KnitNetwork! Segmentation &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;is impossible.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NoEndNodesError</span><span class="p">(</span><span class="n">errMsg</span><span class="p">)</span>

        <span class="c1"># remove contour and &#39;warp&#39; edges and store them</span>
        <span class="n">warp_storage</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">contour_storage</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;weft&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;warp&quot;</span><span class="p">]:</span>
                    <span class="n">warp_storage</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">contour_storage</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># get all &#39;end&#39; nodes ordered by their &#39;position&#39; attribute</span>
        <span class="n">all_ends_by_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_ends_by_position</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># loop through all &#39;end&#39; nodes</span>
        <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">all_ends_by_position</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">endnode</span> <span class="ow">in</span> <span class="n">position</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse_weft_edges_and_set_attributes</span><span class="p">(</span><span class="n">endnode</span><span class="p">)</span>

        <span class="c1"># add all previously removed edges back into the network</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">attr_dict</span><span class="o">=</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">warp_storage</span> <span class="o">+</span> <span class="n">contour_storage</span><span class="p">]</span></div>

    <span class="c1"># CREATION OF MAPPING NETWORK ---------------------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.create_mapping_network"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.create_mapping_network">[docs]</a>    <span class="k">def</span> <span class="nf">create_mapping_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the corresponding mapping network for the final loop generation</span>
<span class="sd">        from a KnitNetwork instance with fully assigned &#39;segment&#39; attributes.</span>

<span class="sd">        The created mapping network will be part of the KnitNetwork instance.</span>
<span class="sd">        It can be accessed using the mapping_network property.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All nodes without an &#39;end&#39; attribute as well as all &#39;weft&#39; edges are</span>
<span class="sd">        removed by this step. Final nodes as well as final &#39;weft&#39; and &#39;warp&#39;</span>
<span class="sd">        edges can only be created using the mapping network.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        success : bool</span>
<span class="sd">            ``True`` if the mapping network has been successfully created,</span>
<span class="sd">            ``False`` otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create a new KnitMappingNetwork instance</span>
        <span class="n">MappingNetwork</span> <span class="o">=</span> <span class="n">KnitMappingNetwork</span><span class="p">()</span>

        <span class="c1"># get all edges of the current network by segment</span>
        <span class="n">weft_edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weft_edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">])</span>
        <span class="n">warp_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp_edges</span>

        <span class="c1"># initialize deque container for segment ids</span>
        <span class="n">segment_ids</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="c1"># loop through all &#39;weft&#39; edges and fill container with unique ids</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">weft_edges</span><span class="p">:</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">segment_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">segment_ids</span><span class="p">:</span>
                <span class="n">segment_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span>

        <span class="c1"># error checking</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">errMsg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;The network contains no &#39;weft&#39; edges with a &#39;segment&#39; &quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;attribute assigned to them. A KnitMappingNetwork can &quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;only be created from a KnitNetwork with initialized &quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;&#39;weft&#39; edges for courses and corresponding &#39;warp&#39; &quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;edges connecting their &#39;end&#39; nodes.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NoWeftEdgesError</span><span class="p">(</span><span class="n">errMsg</span><span class="p">)</span>

        <span class="c1"># loop through all unique segment ids</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">segment_ids</span><span class="p">:</span>
            <span class="c1"># get the corresponding edges for this id and sort them</span>
            <span class="n">segment_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">weft_edges</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">id</span><span class="p">]</span>
            <span class="n">segment_edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># extract start and end nodes</span>
            <span class="n">start_node</span> <span class="o">=</span> <span class="p">(</span><span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">endNode</span> <span class="o">=</span> <span class="p">(</span><span class="nb">id</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="c1"># get all the geometry of the individual edges</span>
            <span class="n">segment_geo</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">segment_edges</span><span class="p">]</span>
            <span class="c1"># create a segment contour edge in the mapping network</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">MappingNetwork</span><span class="o">.</span><span class="n">create_segment_contour_edge</span><span class="p">(</span>
                                                        <span class="n">start_node</span><span class="p">,</span>
                                                        <span class="n">endNode</span><span class="p">,</span>
                                                        <span class="nb">id</span><span class="p">,</span>
                                                        <span class="n">segment_geo</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">errMsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;SegmentContourEdge at segment id </span><span class="si">{}</span><span class="s2"> could not be &quot;</span> <span class="o">+</span>
                          <span class="s2">&quot;created!&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">KnitNetworkError</span><span class="p">(</span><span class="n">errMsg</span><span class="p">)</span>

        <span class="c1"># add all warp edges to the mapping network to avoid lookup hassle</span>
        <span class="k">for</span> <span class="n">warp_edge</span> <span class="ow">in</span> <span class="n">warp_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">warp_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">warp_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">warp_from</span> <span class="o">=</span> <span class="n">warp_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">warp_to</span> <span class="o">=</span> <span class="n">warp_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warp_from</span> <span class="o">=</span> <span class="n">warp_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">warp_to</span> <span class="o">=</span> <span class="n">warp_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">MappingNetwork</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">warp_from</span><span class="p">,</span> <span class="n">warp_to</span><span class="p">,</span> <span class="n">attr_dict</span><span class="o">=</span><span class="n">warp_edge</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># set mapping network property for this instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping_network</span> <span class="o">=</span> <span class="n">MappingNetwork</span>

        <span class="c1"># ditch all edges that are not &#39;warp&#39; and nodes without &#39;end&#39; attribute</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]]</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;warp&quot;</span><span class="p">]]</span>

        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="c1"># MAPPING NETWORK PROPERTY ------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_get_mapping_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the associated mapping network for this KnitNetwork instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping_network</span>

    <span class="k">def</span> <span class="nf">_set_mapping_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping_network</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for this instance&#39;s associated mapping network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set mapping network to instance</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping_network</span><span class="p">,</span> <span class="n">KnitMappingNetwork</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">mapping_network</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mapping_network</span> <span class="o">=</span> <span class="n">mapping_network</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is not of type KnitMappingNetwork!&quot;</span><span class="p">)</span>

    <span class="n">mapping_network</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_mapping_network</span><span class="p">,</span>
                               <span class="n">_set_mapping_network</span><span class="p">,</span>
                               <span class="kc">None</span><span class="p">,</span>
                               <span class="s2">&quot;The associated mapping network of this &quot;</span> <span class="o">+</span>
                               <span class="s2">&quot;KnitNetwork instance.&quot;</span><span class="p">)</span>

    <span class="c1"># RETRIEVAL OF NODES AND EDGES FROM MAPPING NETWORK -----------------------</span>

<div class="viewcode-block" id="KnitNetwork.all_nodes_by_segment"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.all_nodes_by_segment">[docs]</a>    <span class="k">def</span> <span class="nf">all_nodes_by_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all nodes of the network ordered by &#39;segment&#39; attribute.</span>
<span class="sd">        Note: &#39;end&#39; nodes are not included!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : bool, optional</span>
<span class="sd">            If ``True``, the nodes contained in the output will be represented</span>
<span class="sd">            as 2-tuples in the form of (node_identifier, node_data).</span>

<span class="sd">            Defaults to ``False``</span>

<span class="sd">        edges : bool, optional</span>
<span class="sd">            If ``True``, the returned output list will contain 3-tuples in the</span>
<span class="sd">            form of (segment_value, segment_nodes, segment_edge).</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes_by_segment : :obj:`list` of :obj:`tuple`</span>
<span class="sd">            List of 2-tuples in the form of (segment_value, segment_nodes) or</span>
<span class="sd">            3-tuples in the form of (segment_value, segment_nodes,</span>
<span class="sd">            segment_edge) depending on the ``edges`` argument.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        MappingNetworkError</span>
<span class="sd">            If the mapping network is not available for this instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># retrieve mappingnetwork</span>
        <span class="n">mapnet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_network</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mapnet</span><span class="p">:</span>
            <span class="n">errMsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Mapping network has not been built for this instance!&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">MappingNetworkError</span><span class="p">(</span><span class="n">errMsg</span><span class="p">)</span>

        <span class="n">allSegments</span> <span class="o">=</span> <span class="n">mapnet</span><span class="o">.</span><span class="n">segment_contour_edges</span>
        <span class="n">allSegmentNodes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span>
                           <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;segment&quot;</span><span class="p">]]</span>

        <span class="n">segdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">allSegmentNodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">segdict</span><span class="p">:</span>
                <span class="n">segdict</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">segdict</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="n">anbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">allSegments</span><span class="p">:</span>
                <span class="n">segval</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">segnodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segdict</span><span class="p">[</span><span class="n">segval</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">segnodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">anbs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segval</span><span class="p">,</span> <span class="n">segnodes</span><span class="p">,</span> <span class="n">segment</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">allSegments</span><span class="p">:</span>
                <span class="n">segval</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">segnodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segdict</span><span class="p">[</span><span class="n">segval</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">segnodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">anbs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segval</span><span class="p">,</span> <span class="n">segnodes</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">allSegments</span><span class="p">:</span>
                <span class="n">segval</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">segnodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segdict</span><span class="p">[</span><span class="n">segval</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">segnodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">anbs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segval</span><span class="p">,</span> <span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">segnodes</span><span class="p">],</span> <span class="n">segment</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">data</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">allSegments</span><span class="p">:</span>
                <span class="n">segval</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">segnodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segdict</span><span class="p">[</span><span class="n">segval</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">segnodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">anbs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segval</span><span class="p">,</span> <span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">segnodes</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">anbs</span></div>

    <span class="c1"># STITCH WIDTH SAMPLING ---------------------------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.sample_segment_contours"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.sample_segment_contours">[docs]</a>    <span class="k">def</span> <span class="nf">sample_segment_contours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stitch_width</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples the segment contours of the mapping network with the given</span>
<span class="sd">        stitch width. The resulting points are added to the network as nodes</span>
<span class="sd">        and a &#39;segment&#39; attribute is assigned to them based on their origin</span>
<span class="sd">        segment contour edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        stitch_width : float</span>
<span class="sd">            The width of a single stitch inside the knit.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        MappingNetworkError</span>
<span class="sd">            If the mapping network is not available for this instance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># retrieve mapping network</span>
        <span class="n">mapnet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_network</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mapnet</span><span class="p">:</span>
            <span class="n">errMsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Mapping network has not been built for this &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;instance, sampling segment contours is impossible!&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">MappingNetworkError</span><span class="p">(</span><span class="n">errMsg</span><span class="p">)</span>

        <span class="c1"># get the highest index of all the nodes in the network</span>
        <span class="n">maxNode</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

        <span class="c1"># get all the segment geometry ordered by segment number</span>
        <span class="n">segment_contours</span> <span class="o">=</span> <span class="n">mapnet</span><span class="o">.</span><span class="n">segment_contour_edges</span>

        <span class="c1"># sample all segments with the stitch width</span>
        <span class="n">nodeindex</span> <span class="o">=</span> <span class="n">maxNode</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_contours</span><span class="p">):</span>
            <span class="c1"># get the geometry of the contour and reparametreize its domain</span>
            <span class="n">geo</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>
            <span class="n">geo</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">ToPolylineCurve</span><span class="p">()</span>
            <span class="n">geo</span><span class="o">.</span><span class="n">Domain</span> <span class="o">=</span> <span class="n">RhinoInterval</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="c1"># compute the division points</span>
            <span class="n">crvlen</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">GetLength</span><span class="p">()</span>
            <span class="n">density</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">crvlen</span> <span class="o">/</span> <span class="n">stitch_width</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">density</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">divT</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">DivideByCount</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">divPts</span> <span class="o">=</span> <span class="p">[</span><span class="n">geo</span><span class="o">.</span><span class="n">PointAt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">divT</span><span class="p">]</span>

            <span class="c1"># set leaf attribute</span>
            <span class="c1"># TODO: better leaf strategy - this works but assigns false</span>
            <span class="c1"># leaf nodes. usually not a problem but it should be fixed anyway</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;leaf&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;leaf&quot;</span><span class="p">]:</span>
                <span class="n">nodeLeaf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodeLeaf</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># add all the nodes to the network</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">divPts</span><span class="p">):</span>
                <span class="c1"># add node to network</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_from_point3d</span><span class="p">(</span>
                                    <span class="n">nodeindex</span><span class="p">,</span>
                                    <span class="n">pt</span><span class="p">,</span>
                                    <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">num</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                                    <span class="n">leaf</span><span class="o">=</span><span class="n">nodeLeaf</span><span class="p">,</span>
                                    <span class="n">start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">segment</span><span class="o">=</span><span class="n">seg</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">],</span>
                                    <span class="n">increase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">decrease</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="c1"># increment node index</span>
                <span class="n">nodeindex</span> <span class="o">+=</span> <span class="mi">1</span></div>

    <span class="c1"># CREATION OF FINAL &#39;WEFT&#39; CONNECTIONS ------------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.create_final_weft_connections"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.create_final_weft_connections">[docs]</a>    <span class="k">def</span> <span class="nf">create_final_weft_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop through all the segment contour edges and create all &#39;weft&#39;</span>
<span class="sd">        connections for this network.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get all nodes by segment contour</span>
        <span class="n">SegmentValues</span><span class="p">,</span> <span class="n">AllNodesBySegment</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">all_nodes_by_segment</span><span class="p">(</span>
                                                                    <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># loop through all the segment contours</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">AllNodesBySegment</span><span class="p">):</span>
            <span class="n">segval</span> <span class="o">=</span> <span class="n">SegmentValues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">firstNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">segval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">segval</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">lastNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">segval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">segval</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">firstNode</span><span class="p">,</span> <span class="n">lastNode</span><span class="p">,</span> <span class="n">segval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">firstNode</span><span class="p">,</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segval</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lastNode</span><span class="p">,</span> <span class="n">segval</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># loop through all nodes on the current segment and create</span>
                <span class="c1"># the final &#39;weft&#39; edges</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">firstNode</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">segval</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">segment</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">segval</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">segment</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">segval</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">lastNode</span><span class="p">,</span> <span class="n">segval</span><span class="p">)</span></div>

    <span class="c1"># CREATION OF FINAL &#39;WARP&#39; CONNECTIONS ------------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.attempt_warp_connection"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.attempt_warp_connection">[docs]</a>    <span class="k">def</span> <span class="nf">attempt_warp_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">source_nodes</span><span class="p">,</span>
                                <span class="n">max_connections</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for attempting a &#39;warp&#39; connection to a candidate</span>
<span class="sd">        node based on certain parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : node</span>
<span class="sd">            The starting node for the possible &#39;weft&#39; edge.</span>

<span class="sd">        candidate : node</span>
<span class="sd">            The target node for the possible &#39;weft&#39; edge.</span>

<span class="sd">        source_nodes : :obj:`list`</span>
<span class="sd">            List of nodes on the position contour of node. Used to check if</span>
<span class="sd">            the candidate node already has a connection.</span>

<span class="sd">        max_connections : int, optional</span>
<span class="sd">            The new &#39;weft&#39; connection will only be made if the candidate nodes</span>
<span class="sd">            number of connected neighbors is below this.</span>

<span class="sd">            Defaults to ``4``.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``True``, this routine and all its subroutines will print</span>
<span class="sd">            messages about what is happening to the console.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : bool</span>
<span class="sd">            True if the connection has been made, otherwise false.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># define verbose print function</span>
        <span class="n">v_print</span> <span class="o">=</span> <span class="nb">print</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span>

        <span class="n">connecting_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connecting_neighbors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_connections</span><span class="p">:</span>
            <span class="n">isConnected</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">connecting_neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">]:</span>
                    <span class="n">isConnected</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Candidate node </span><span class="si">{}</span><span class="s2"> is &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                            <span class="s2">&quot;already connected! Skipping to next node...&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isConnected</span><span class="p">:</span>
                <span class="c1"># print info on verbose setting</span>
                <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Connecting node </span><span class="si">{}</span><span class="s2"> to best candidate </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                <span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="c1"># finally create the warp edge for good</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">_create_initial_warp_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment_pair</span><span class="p">,</span> <span class="n">max_connections</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                         <span class="n">precise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method for creating first pass &#39;warp&#39; connections for the</span>
<span class="sd">        supplied pair of segment chains.</span>
<span class="sd">        The pair is only defined as a list of nodes, the nodes have to be</span>
<span class="sd">        supplied with their attribute data!</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># define verbose print function</span>
        <span class="n">v_print</span> <span class="o">=</span> <span class="nb">print</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_pair</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Not enough contour segments in supplied set!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># print info on verbose output</span>
        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Creating initial &#39;warp&#39; connections for contour set...&quot;</span><span class="p">)</span>

        <span class="c1"># get initial and target nodes without &#39;end&#39; nodes</span>
        <span class="n">initial_nodes</span> <span class="o">=</span> <span class="n">segment_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">target_nodes</span> <span class="o">=</span> <span class="n">segment_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># define forbidden node index</span>
        <span class="n">forbidden_node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># do nothing if one of the sets is empty</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># loop through all nodes on the current segment</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">):</span>
            <span class="c1"># get geometry from current node</span>
            <span class="n">thisPt</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>

            <span class="c1"># print info on verbose setting</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Processing node </span><span class="si">{}</span><span class="s2"> on segment </span><span class="si">{}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                        <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                        <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]))</span>

            <span class="c1"># filtering according to forbidden nodes</span>
            <span class="k">if</span> <span class="n">forbidden_node</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">target_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tnode</span> <span class="k">for</span> <span class="n">tx</span><span class="p">,</span> <span class="n">tnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">tx</span> <span class="o">&gt;=</span> <span class="n">target_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">forbidden_node</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># compute distances to target nodes</span>
            <span class="k">if</span> <span class="n">precise</span><span class="p">:</span>
                <span class="n">allDists</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisPt</span><span class="o">.</span><span class="n">DistanceTo</span><span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">tn</span> <span class="ow">in</span> <span class="n">target_nodes</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">allDists</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisPt</span><span class="o">.</span><span class="n">DistanceToSquared</span><span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">tn</span> <span class="ow">in</span> <span class="n">target_nodes</span><span class="p">]</span>

            <span class="c1"># sort nodes after distances</span>
            <span class="n">allDists</span><span class="p">,</span> <span class="n">sorted_target_nodes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span>
                                                <span class="nb">zip</span><span class="p">(</span><span class="n">allDists</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">),</span>
                                                <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

            <span class="c1"># the four nearest nodes are the possible connections</span>
            <span class="n">possible_connections</span> <span class="o">=</span> <span class="n">sorted_target_nodes</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
            <span class="c1"># print info on verbose setting</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Possible connections: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="n">pc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span>
                                                       <span class="n">possible_connections</span><span class="p">]))</span>

            <span class="c1"># handle edge case where there is no possible connection or just</span>
            <span class="c1"># one</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># attempt to connect to only possible candidate</span>
                <span class="n">fCand</span> <span class="o">=</span> <span class="n">possible_connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_warp_connection</span><span class="p">(</span>
                                            <span class="n">node</span><span class="p">,</span>
                                            <span class="n">fCand</span><span class="p">,</span>
                                            <span class="n">initial_nodes</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="c1"># set forbidden node</span>
                <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">forbidden_node</span> <span class="o">=</span> <span class="n">fCand</span>
                <span class="k">continue</span>

            <span class="c1"># get the segment contours current direction</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">contourDir</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span><span class="n">thisPt</span><span class="p">,</span>
                                       <span class="n">initial_nodes</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">Direction</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">contourDir</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                                <span class="n">initial_nodes</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">],</span> <span class="n">thisPt</span><span class="p">)</span><span class="o">.</span><span class="n">Direction</span>
            <span class="n">contourDir</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>

            <span class="c1"># get the directions of the possible connections</span>
            <span class="n">candidatePoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">possible_connections</span><span class="p">]</span>
            <span class="n">candidateDirections</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoLine</span><span class="p">(</span>
                            <span class="n">thisPt</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">Direction</span> <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">candidatePoints</span><span class="p">]</span>
            <span class="p">[</span><span class="n">cd</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">candidateDirections</span><span class="p">]</span>

            <span class="c1"># get the angles between segment contour dir and possible conn dir</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">CrossProduct</span><span class="p">(</span>
                       <span class="n">contourDir</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">candidateDirections</span><span class="p">]</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">VectorAngle</span><span class="p">(</span>
                      <span class="n">contourDir</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">cd</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                      <span class="n">candidateDirections</span><span class="p">,</span> <span class="n">normals</span><span class="p">)]</span>

            <span class="c1"># compute deltas as a measure of perpendicularity</span>
            <span class="n">deltas</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>

            <span class="c1"># sort possible connections first by distance, then by delta</span>
            <span class="p">(</span><span class="n">allDists</span><span class="p">,</span>
             <span class="n">deltas</span><span class="p">,</span>
             <span class="n">angles</span><span class="p">,</span>
             <span class="n">most_perpendicular</span><span class="p">)</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">allDists</span><span class="p">,</span>
                                                   <span class="n">deltas</span><span class="p">,</span>
                                                   <span class="n">angles</span><span class="p">,</span>
                                                   <span class="n">possible_connections</span><span class="p">[:]),</span>
                                               <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

            <span class="c1"># compute angle difference</span>
            <span class="n">aDelta</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># get node neighbors</span>
            <span class="n">nNeighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="c1"># CONNECTION FOR LEAST ANGLE CHANGE -------------------------------</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nNeighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">aDelta</span> <span class="o">&lt;</span> <span class="n">radians</span><span class="p">(</span><span class="mf">6.0</span><span class="p">):</span>
                <span class="c1"># print info on verbose setting</span>
                <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Using procedure for least angle &quot;</span> <span class="o">+</span>
                        <span class="s2">&quot;change connection...&quot;</span><span class="p">)</span>

                <span class="c1"># get previous connected edge and its direction</span>
                <span class="n">prevEdges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_warp_edges</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prevEdges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;More than one previous &quot;</span> <span class="o">+</span>
                          <span class="s2">&quot;&#39;warp&#39; connection! This was unexpected...&quot;</span> <span class="o">+</span>
                          <span class="s2">&quot;Taking the first one..?&quot;</span><span class="p">)</span>
                    <span class="n">prevDir</span> <span class="o">=</span> <span class="n">prevEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">Direction</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prevDir</span> <span class="o">=</span> <span class="n">prevEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">Direction</span>
                <span class="n">prevDir</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>

                <span class="c1"># get directions for the best two candidates</span>
                <span class="n">mpA</span> <span class="o">=</span> <span class="n">most_perpendicular</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mpB</span> <span class="o">=</span> <span class="n">most_perpendicular</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">dirA</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span><span class="n">thisPt</span><span class="p">,</span> <span class="n">mpA</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">Direction</span>
                <span class="n">dirB</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span><span class="n">thisPt</span><span class="p">,</span> <span class="n">mpB</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">Direction</span>
                <span class="n">dirA</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>
                <span class="n">dirB</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>

                <span class="c1"># get normals for angle measurement</span>
                <span class="n">normalA</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">prevDir</span><span class="p">,</span> <span class="n">dirA</span><span class="p">)</span>
                <span class="n">normalB</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">prevDir</span><span class="p">,</span> <span class="n">dirB</span><span class="p">)</span>

                <span class="c1"># measure the angles</span>
                <span class="n">angleA</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">VectorAngle</span><span class="p">(</span><span class="n">prevDir</span><span class="p">,</span> <span class="n">dirA</span><span class="p">,</span> <span class="n">normalA</span><span class="p">)</span>
                <span class="n">angleB</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">VectorAngle</span><span class="p">(</span><span class="n">prevDir</span><span class="p">,</span> <span class="n">dirB</span><span class="p">,</span> <span class="n">normalB</span><span class="p">)</span>

                <span class="c1"># select final candidate for connection</span>
                <span class="k">if</span> <span class="n">angleA</span> <span class="o">&lt;</span> <span class="n">angleB</span><span class="p">:</span>
                    <span class="n">fCand</span> <span class="o">=</span> <span class="n">mpA</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fCand</span> <span class="o">=</span> <span class="n">mpB</span>

                <span class="c1"># attempt connection to final candidate</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_warp_connection</span><span class="p">(</span>
                                            <span class="n">node</span><span class="p">,</span>
                                            <span class="n">fCand</span><span class="p">,</span>
                                            <span class="n">initial_nodes</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="c1"># set forbidden node</span>
                <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">forbidden_node</span> <span class="o">=</span> <span class="n">fCand</span>
                <span class="k">continue</span>

            <span class="c1"># CONNECTION FOR MOST PERPENDICULAR -------------------------------</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># print info on verbose setting</span>
                <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Using procedure for most &quot;</span> <span class="o">+</span>
                        <span class="s2">&quot;perpendicular connection...&quot;</span><span class="p">)</span>
                <span class="c1"># define final candidate node</span>
                <span class="n">fCand</span> <span class="o">=</span> <span class="n">most_perpendicular</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># attempt connection to final candidate</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_warp_connection</span><span class="p">(</span>
                                            <span class="n">node</span><span class="p">,</span>
                                            <span class="n">fCand</span><span class="p">,</span>
                                            <span class="n">initial_nodes</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="c1"># set forbidden node</span>
                <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">forbidden_node</span> <span class="o">=</span> <span class="n">fCand</span>

    <span class="k">def</span> <span class="nf">_create_second_pass_warp_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_nodes</span><span class="p">,</span> <span class="n">source_index</span><span class="p">,</span>
                                            <span class="n">window</span><span class="p">,</span> <span class="n">precise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method for creating second pass &#39;warp&#39; connections for the</span>
<span class="sd">        given set of contours.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># define verbose print function</span>
        <span class="n">v_print</span> <span class="o">=</span> <span class="nb">print</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># print info on verbose setting</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Length of window is 0, skipping...&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># print info on verbose setting</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Window has only one node.&quot;</span><span class="p">)</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Connecting to node </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

            <span class="c1"># connect &#39;warp&#39; edge</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source_nodes</span><span class="p">[</span><span class="n">source_index</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">[</span><span class="n">source_index</span><span class="p">],</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># retrive the point of the current source node</span>
            <span class="n">thisPt</span> <span class="o">=</span> <span class="n">source_nodes</span><span class="p">[</span><span class="n">source_index</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>

            <span class="c1"># print info on verbose setting</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Processing window nodes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                    <span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]))</span>

            <span class="c1"># sort nodes in window by distance</span>
            <span class="k">if</span> <span class="n">precise</span><span class="p">:</span>
                <span class="n">allDists</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisPt</span><span class="o">.</span><span class="n">DistanceTo</span><span class="p">(</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">allDists</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisPt</span><span class="o">.</span><span class="n">DistanceToSquared</span><span class="p">(</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]</span>
            <span class="n">allDists</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">allDists</span><span class="p">,</span> <span class="n">window</span><span class="p">),</span>
                                   <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

            <span class="c1"># get the contours current direction</span>
            <span class="k">if</span> <span class="n">source_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sourceDir</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                            <span class="n">thisPt</span><span class="p">,</span>
                            <span class="n">source_nodes</span><span class="p">[</span><span class="n">source_index</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">Direction</span>
            <span class="k">elif</span> <span class="n">source_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sourceDir</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">[</span><span class="n">source_index</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">],</span>
                                      <span class="n">thisPt</span><span class="p">)</span><span class="o">.</span><span class="n">Direction</span>
            <span class="n">sourceDir</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span>

            <span class="c1"># get the directions of the possible connections</span>
            <span class="n">candidatePoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]</span>
            <span class="n">candidateDirections</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoLine</span><span class="p">(</span><span class="n">thisPt</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">Direction</span> <span class="k">for</span> <span class="n">cp</span>
                                   <span class="ow">in</span> <span class="n">candidatePoints</span><span class="p">]</span>
            <span class="p">[</span><span class="n">cd</span><span class="o">.</span><span class="n">Unitize</span><span class="p">()</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">candidateDirections</span><span class="p">]</span>

            <span class="c1"># get the angles between contour dir and window dir</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">sourceDir</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">candidateDirections</span><span class="p">]</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">RhinoVector3d</span><span class="o">.</span><span class="n">VectorAngle</span><span class="p">(</span><span class="n">sourceDir</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">cd</span><span class="p">,</span> <span class="n">n</span>
                      <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidateDirections</span><span class="p">,</span> <span class="n">normals</span><span class="p">)]</span>

            <span class="c1"># compute deltas as a mesaure of perpendicularity</span>
            <span class="n">deltas</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>

            <span class="c1"># sort window by distance, then by delta</span>
            <span class="n">allDists</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">most_perpendicular</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span>
                                                    <span class="nb">zip</span><span class="p">(</span><span class="n">allDists</span><span class="p">,</span>
                                                        <span class="n">deltas</span><span class="p">,</span>
                                                        <span class="n">window</span><span class="p">),</span>
                                                    <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="c1"># set final candidate node for connection</span>
            <span class="n">fCand</span> <span class="o">=</span> <span class="n">most_perpendicular</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># print info on verbose setting</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Connecting to node &quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> on segment </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fCand</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                 <span class="n">fCand</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;segment&quot;</span><span class="p">]))</span>

            <span class="c1"># connect warp edge to best target</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">fCand</span><span class="p">,</span> <span class="n">source_nodes</span><span class="p">[</span><span class="n">source_index</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">[</span><span class="n">source_index</span><span class="p">],</span> <span class="n">fCand</span><span class="p">)</span>

<div class="viewcode-block" id="KnitNetwork.create_final_warp_connections"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.create_final_warp_connections">[docs]</a>    <span class="k">def</span> <span class="nf">create_final_warp_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_connections</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                      <span class="n">include_end_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">precise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the final &#39;warp&#39; connections by building chains of segment</span>
<span class="sd">        contour edges and connecting them.</span>

<span class="sd">        For each source chain, a target chain is found using an</span>
<span class="sd">        &#39;educated guessing&#39; strategy. This means that the possible target</span>
<span class="sd">        chains are guessed by leveraging known topology facts about the network</span>
<span class="sd">        and its special &#39;end&#39; nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_connections : int, optional</span>
<span class="sd">            The number of maximum previous connections a candidate node for a</span>
<span class="sd">            &#39;warp&#39; connection is allowed to have.</span>

<span class="sd">            Defaults to ``4``.</span>

<span class="sd">        include_end_nodes : bool, optional</span>
<span class="sd">            If ``True``, &#39;end&#39; nodes between adjacent segment contours in a</span>
<span class="sd">            source chain will be included in the first pass of connecting</span>
<span class="sd">            &#39;warp&#39; edges.</span>

<span class="sd">            Defaults to ``True``.</span>

<span class="sd">        precise : bool</span>
<span class="sd">            If ``True``, the distance between nodes will be calculated using</span>
<span class="sd">            the Rhino.Geometry.Point3d.DistanceTo method, otherwise the much</span>
<span class="sd">            faster Rhino.Geometry.Point3d.DistanceToSquared method is used.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``True``, this routine and all its subroutines will print</span>
<span class="sd">            messages about what is happening to the console. Great for</span>
<span class="sd">            debugging and analysis.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># define verbose print function</span>
        <span class="n">v_print</span> <span class="o">=</span> <span class="nb">print</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span>

        <span class="c1"># get all segment ids, nodes per segment and edges</span>
        <span class="n">SegmentValues</span><span class="p">,</span> <span class="n">AllNodesBySegment</span><span class="p">,</span> <span class="n">SegmentContourEdges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                        <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">all_nodes_by_segment</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># build a dictionary of the segments by their index</span>
        <span class="n">SegmentDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">SegmentValues</span><span class="p">,</span>
                               <span class="nb">zip</span><span class="p">(</span><span class="n">SegmentContourEdges</span><span class="p">,</span> <span class="n">AllNodesBySegment</span><span class="p">)))</span>

        <span class="c1"># build source and target chains</span>
        <span class="n">source_chains</span><span class="p">,</span> <span class="n">target_chain_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_network</span><span class="o">.</span><span class="n">build_chains</span><span class="p">(</span>
                                                                    <span class="kc">False</span><span class="p">,</span>
                                                                    <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># initialize container dict for connected chains</span>
        <span class="n">connected_chains</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># initialize segment mapping dictionaries</span>
        <span class="n">source_to_target</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">target_to_source</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">source_to_key</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">target_to_key</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># ITERATE OVER SOURCE SEGMENT CHAINS ----------------------------------</span>

        <span class="c1"># loop through all source chains and find targets in target chains</span>
        <span class="c1"># using an &#39;educated guess strategy&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">source_chain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source_chains</span><span class="p">):</span>
            <span class="c1"># get the first and last node (&#39;end&#39; nodes)</span>
            <span class="n">firstNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_chain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">source_chain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">lastNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_chain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">source_chain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
            <span class="c1"># get the chain value of the current chain</span>
            <span class="n">chain_value</span> <span class="o">=</span> <span class="n">source_chain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># extract the ids of the current chain</span>
            <span class="n">current_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">source_chain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># extract the current chains geometry</span>
            <span class="n">current_chain_geo_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>
                                      <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">current_ids</span><span class="p">]</span>
            <span class="n">current_chain_geo</span> <span class="o">=</span> <span class="n">RhinoCurve</span><span class="o">.</span><span class="n">JoinCurves</span><span class="p">(</span>
                <span class="p">[</span><span class="n">ccg</span><span class="o">.</span><span class="n">ToPolylineCurve</span><span class="p">()</span> <span class="k">for</span> <span class="n">ccg</span> <span class="ow">in</span> <span class="n">current_chain_geo_list</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">current_chain_spt</span> <span class="o">=</span> <span class="n">current_chain_geo</span><span class="o">.</span><span class="n">PointAtNormalizedLength</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="c1"># retrieve the current segments from the segment dictionary by id</span>
            <span class="n">current_segment_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">current_ids</span><span class="p">]</span>
            <span class="c1"># retrieve the current nodes from the list of current segments</span>
            <span class="n">current_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">csn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_segment_nodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">include_end_nodes</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">current_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">current_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">current_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="p">[</span><span class="n">current_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">csn</span><span class="p">]</span>

            <span class="c1"># reset the target key</span>
            <span class="n">target_key</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># print info on verbose setting</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;--------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Processing segment chain </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">source_chain</span><span class="p">))</span>

            <span class="c1"># CASE 1 - ENCLOSED SHORT ROW &lt;====&gt; ALL CASES --------------------</span>

            <span class="c1"># look for possible targets using a guess about the chain value</span>
            <span class="n">possible_target_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">target_chain_dict</span>
                                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">connected_chains</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_target_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># find the correct chain by using geometric distance</span>
                <span class="n">possible_target_chains</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_chain_dict</span><span class="p">[</span><span class="n">tk</span><span class="p">]</span> <span class="k">for</span> <span class="n">tk</span>
                                          <span class="ow">in</span> <span class="n">possible_target_keys</span><span class="p">]</span>
                <span class="c1"># for every chain in the possible target chains, get the</span>
                <span class="c1"># geometry and compute a sample distance</span>
                <span class="n">filtered_target_keys</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">possible_target_chain_dists</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ptc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">possible_target_chains</span><span class="p">):</span>
                    <span class="c1"># retrieve possible target geometry and join into one crv</span>
                    <span class="n">ptc_geo_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ptc</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ptc_geo_list</span> <span class="o">==</span> <span class="n">current_chain_geo_list</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">ptc_geo</span> <span class="o">=</span> <span class="n">RhinoCurve</span><span class="o">.</span><span class="n">JoinCurves</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">ptcg</span><span class="o">.</span><span class="n">ToPolylineCurve</span><span class="p">()</span> <span class="k">for</span> <span class="n">ptcg</span> <span class="ow">in</span> <span class="n">ptc_geo_list</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># get a sample point and measure the distance to the</span>
                    <span class="c1"># source chain sample point</span>
                    <span class="n">ptc_spt</span> <span class="o">=</span> <span class="n">ptc_geo</span><span class="o">.</span><span class="n">PointAtNormalizedLength</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">precise</span><span class="p">:</span>
                        <span class="n">ptc_dist</span> <span class="o">=</span> <span class="n">current_chain_spt</span><span class="o">.</span><span class="n">DistanceTo</span><span class="p">(</span><span class="n">ptc_spt</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ptc_dist</span> <span class="o">=</span> <span class="n">current_chain_spt</span><span class="o">.</span><span class="n">DistanceToSquared</span><span class="p">(</span><span class="n">ptc_spt</span><span class="p">)</span>
                    <span class="c1"># append the filtered key to the key list</span>
                    <span class="n">filtered_target_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">possible_target_keys</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="c1"># append the measured distance to the distance list</span>
                    <span class="n">possible_target_chain_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptc_dist</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_target_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># sort filtered target keys using the distances</span>
                    <span class="n">possible_target_chain_dists</span><span class="p">,</span> <span class="n">filtered_target_keys</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                                    <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                                                <span class="n">possible_target_chain_dists</span><span class="p">,</span>
                                                <span class="n">filtered_target_keys</span><span class="p">),</span>
                                            <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
                    <span class="c1"># set target key</span>
                    <span class="n">target_key</span> <span class="o">=</span> <span class="n">filtered_target_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target_key</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># attempt warp connections if we have found a correct key</span>
            <span class="k">if</span> <span class="n">target_key</span><span class="p">:</span>
                <span class="c1"># get the guessed target chain from the chain dictionary</span>
                <span class="n">target_chain</span> <span class="o">=</span> <span class="n">target_chain_dict</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span>
                <span class="c1"># extract the ids for node retrieval</span>
                <span class="n">target_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">seg</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">target_chain</span><span class="p">])</span>
                <span class="c1"># retrieve the target nodes from the segment dictionary by id</span>
                <span class="n">target_segment_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">target_ids</span><span class="p">]</span>
                <span class="n">target_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tsn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_segment_nodes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">include_end_nodes</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                                <span class="n">target_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">target_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
                    <span class="p">[</span><span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tsn</span><span class="p">]</span>

                <span class="c1"># print info on verbose setting</span>
                <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;&lt;=====&gt; detected. Connecting to &quot;</span> <span class="o">+</span>
                        <span class="s2">&quot;segment chain </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_key</span><span class="p">))</span>

                <span class="c1"># we have successfully verified our target segment and</span>
                <span class="c1"># can create some warp edges!</span>
                <span class="n">segment_pair</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_nodes</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">]</span>

                <span class="c1"># fill mapping dictionaries</span>
                <span class="k">if</span> <span class="n">current_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_to_target</span><span class="p">:</span>
                    <span class="n">source_to_target</span><span class="p">[</span><span class="n">current_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_ids</span>
                <span class="k">if</span> <span class="n">current_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_to_key</span><span class="p">:</span>
                    <span class="n">source_to_key</span><span class="p">[</span><span class="n">current_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">chain_value</span>
                <span class="k">if</span> <span class="n">target_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_to_source</span><span class="p">:</span>
                    <span class="n">target_to_source</span><span class="p">[</span><span class="n">target_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_ids</span>
                <span class="k">if</span> <span class="n">target_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_to_key</span><span class="p">:</span>
                    <span class="n">target_to_key</span><span class="p">[</span><span class="n">target_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_key</span>

                <span class="c1"># create initial warp connections between the chains</span>
                <span class="n">connected_chains</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_initial_warp_connections</span><span class="p">(</span>
                                            <span class="n">segment_pair</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># CASE 2 - SHORT ROW TO THE RIGHT &lt;=====/ ALL CASES ---------------</span>

            <span class="c1"># look for possible targets using a guess about the chain value</span>
            <span class="n">possible_target_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">target_chain_dict</span>
                                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
                                    <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">connected_chains</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_target_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="n">possible_target_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_target_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># find the correct chain by using geometric distance</span>
                <span class="n">possible_target_chains</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_chain_dict</span><span class="p">[</span><span class="n">tk</span><span class="p">]</span> <span class="k">for</span> <span class="n">tk</span>
                                          <span class="ow">in</span> <span class="n">possible_target_keys</span><span class="p">]</span>
                <span class="c1"># for every chain in the possible target chains, get the</span>
                <span class="c1"># geometry and compute a sample distance</span>
                <span class="n">possible_target_chain_dists</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ptc</span> <span class="ow">in</span> <span class="n">possible_target_chains</span><span class="p">:</span>
                    <span class="c1"># retrieve possible target geometry and join into one crv</span>
                    <span class="n">ptc_geo</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ptc</span><span class="p">]</span>
                    <span class="n">ptc_geo</span> <span class="o">=</span> <span class="n">RhinoCurve</span><span class="o">.</span><span class="n">JoinCurves</span><span class="p">([</span><span class="n">pg</span><span class="o">.</span><span class="n">ToPolylineCurve</span><span class="p">()</span>
                                                     <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="n">ptc_geo</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># get a sample point and measure the distance to the</span>
                    <span class="c1"># source chain sample point</span>
                    <span class="n">ptc_spt</span> <span class="o">=</span> <span class="n">ptc_geo</span><span class="o">.</span><span class="n">PointAtNormalizedLength</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">precise</span><span class="p">:</span>
                        <span class="n">ptc_dist</span> <span class="o">=</span> <span class="n">current_chain_spt</span><span class="o">.</span><span class="n">DistanceTo</span><span class="p">(</span><span class="n">ptc_spt</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ptc_dist</span> <span class="o">=</span> <span class="n">current_chain_spt</span><span class="o">.</span><span class="n">DistanceToSquared</span><span class="p">(</span><span class="n">ptc_spt</span><span class="p">)</span>
                    <span class="c1"># append the measured distance to the list</span>
                    <span class="n">possible_target_chain_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptc_dist</span><span class="p">)</span>
                <span class="c1"># sort possible target keys using the distances</span>
                <span class="n">possible_target_chain_dists</span><span class="p">,</span> <span class="n">possible_target_keys</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                                    <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">possible_target_chain_dists</span><span class="p">,</span>
                                                <span class="n">possible_target_keys</span><span class="p">),</span>
                                            <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="n">possible_target_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># attempt warp connections if we have found a correct key</span>
            <span class="k">if</span> <span class="n">target_key</span><span class="p">:</span>
                <span class="c1"># get the guessed target chain from the chain dictionary</span>
                <span class="n">target_chain</span> <span class="o">=</span> <span class="n">target_chain_dict</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span>
                <span class="c1"># extract the ids for node retrieval</span>
                <span class="n">target_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">seg</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">target_chain</span><span class="p">])</span>
                <span class="c1"># retrieve the target nodes from the segment dictionary by id</span>
                <span class="n">target_segment_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">target_ids</span><span class="p">]</span>
                <span class="n">target_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tsn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_segment_nodes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">include_end_nodes</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">target_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
                    <span class="p">[</span><span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tsn</span><span class="p">]</span>

                <span class="n">targetFirstNode</span> <span class="o">=</span> <span class="n">target_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">targetLastNode</span> <span class="o">=</span> <span class="n">target_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># check if firstNode and targetFirstNode are connected via a</span>
                <span class="c1"># &#39;warp&#39; edge to verify</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">targetFirstNode</span> <span class="o">==</span> <span class="n">firstNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">targetLastNode</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">lastNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;&lt;=====/ detected. Connecting &quot;</span> <span class="o">+</span>
                            <span class="s2">&quot;to segment </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_key</span><span class="p">))</span>
                    <span class="c1"># we have successfully verified our target segment and</span>
                    <span class="c1"># can create some warp edges!</span>
                    <span class="n">segment_pair</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_nodes</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">]</span>
                    <span class="n">connected_chains</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># fill mapping dictionaries</span>
                    <span class="k">if</span> <span class="n">current_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_to_target</span><span class="p">:</span>
                        <span class="n">source_to_target</span><span class="p">[</span><span class="n">current_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_ids</span>
                    <span class="k">if</span> <span class="n">current_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_to_key</span><span class="p">:</span>
                        <span class="n">source_to_key</span><span class="p">[</span><span class="n">current_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">chain_value</span>
                    <span class="k">if</span> <span class="n">target_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_to_source</span><span class="p">:</span>
                        <span class="n">target_to_source</span><span class="p">[</span><span class="n">target_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_ids</span>
                    <span class="k">if</span> <span class="n">target_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_to_key</span><span class="p">:</span>
                        <span class="n">target_to_key</span><span class="p">[</span><span class="n">target_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_key</span>

                    <span class="c1"># create initial &#39;warp&#39; connections between the chains</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_create_initial_warp_connections</span><span class="p">(</span>
                                            <span class="n">segment_pair</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;No real connection for &lt;=====/. Next case...&quot;</span><span class="p">)</span>

            <span class="c1"># CASE 3 - SHORT ROW TO THE LEFT /====&gt; ALL CASES -----------------</span>

            <span class="c1"># look for possible targets using a guess about the chain value</span>
            <span class="n">possible_target_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">target_chain_dict</span>
                                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
                                    <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">connected_chains</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_target_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="n">possible_target_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_target_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># find the correct chain by using geometric distance</span>
                <span class="n">possible_target_chains</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_chain_dict</span><span class="p">[</span><span class="n">tk</span><span class="p">]</span> <span class="k">for</span> <span class="n">tk</span>
                                          <span class="ow">in</span> <span class="n">possible_target_keys</span><span class="p">]</span>
                <span class="c1"># for every chain in the possible target chains, get the</span>
                <span class="c1"># geometry and compute a sample distance</span>
                <span class="n">possible_target_chain_dists</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ptc</span> <span class="ow">in</span> <span class="n">possible_target_chains</span><span class="p">:</span>
                    <span class="c1"># retrieve possible target geometry and join into one crv</span>
                    <span class="n">ptc_geo</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ptc</span><span class="p">]</span>
                    <span class="n">ptc_geo</span> <span class="o">=</span> <span class="n">RhinoCurve</span><span class="o">.</span><span class="n">JoinCurves</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">ToPolylineCurve</span><span class="p">()</span> <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="n">ptc_geo</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># get a sample point and measure the distance to the</span>
                    <span class="c1"># source chain sample point</span>
                    <span class="n">ptc_spt</span> <span class="o">=</span> <span class="n">ptc_geo</span><span class="o">.</span><span class="n">PointAtNormalizedLength</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">precise</span><span class="p">:</span>
                        <span class="n">ptc_dist</span> <span class="o">=</span> <span class="n">current_chain_spt</span><span class="o">.</span><span class="n">DistanceTo</span><span class="p">(</span><span class="n">ptc_spt</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ptc_dist</span> <span class="o">=</span> <span class="n">current_chain_spt</span><span class="o">.</span><span class="n">DistanceToSquared</span><span class="p">(</span><span class="n">ptc_spt</span><span class="p">)</span>
                    <span class="c1"># append the measured distance to the list</span>
                    <span class="n">possible_target_chain_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptc_dist</span><span class="p">)</span>
                <span class="c1"># sort possible target keys using the distances</span>
                <span class="n">possible_target_chain_dists</span><span class="p">,</span> <span class="n">possible_target_keys</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                                    <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">possible_target_chain_dists</span><span class="p">,</span>
                                                <span class="n">possible_target_keys</span><span class="p">),</span>
                                            <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="n">possible_target_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># attempt warp connections if we have found a correct key</span>
            <span class="k">if</span> <span class="n">target_key</span><span class="p">:</span>
                <span class="c1"># get the guessed target chain from the chain dictionary</span>
                <span class="n">target_chain</span> <span class="o">=</span> <span class="n">target_chain_dict</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span>
                <span class="c1"># extract the ids for node retrieval</span>
                <span class="n">target_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">seg</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">target_chain</span><span class="p">])</span>
                <span class="c1"># retrieve the target nodes from the segment dictionary by id</span>
                <span class="n">target_segment_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">target_ids</span><span class="p">]</span>
                <span class="n">target_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tsn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_segment_nodes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">include_end_nodes</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">target_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
                    <span class="p">[</span><span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tsn</span><span class="p">]</span>

                <span class="n">targetFirstNode</span> <span class="o">=</span> <span class="n">target_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">targetLastNode</span> <span class="o">=</span> <span class="n">target_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># check if firstNode and targetFirstNode are connected via a</span>
                <span class="c1"># &#39;warp&#39; edge to verify</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">targetFirstNode</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">firstNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="ow">and</span> <span class="n">targetLastNode</span> <span class="o">==</span> <span class="n">lastNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;/=====&gt; detected. Connecting &quot;</span> <span class="o">+</span>
                            <span class="s2">&quot;to segment </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_key</span><span class="p">))</span>
                    <span class="c1"># we have successfully verified our target segment and</span>
                    <span class="c1"># can create some warp edges!</span>
                    <span class="n">segment_pair</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_nodes</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">]</span>
                    <span class="n">connected_chains</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># fill mapping dictionaries</span>
                    <span class="k">if</span> <span class="n">current_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_to_target</span><span class="p">:</span>
                        <span class="n">source_to_target</span><span class="p">[</span><span class="n">current_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_ids</span>
                    <span class="k">if</span> <span class="n">current_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_to_key</span><span class="p">:</span>
                        <span class="n">source_to_key</span><span class="p">[</span><span class="n">current_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">chain_value</span>
                    <span class="k">if</span> <span class="n">target_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_to_source</span><span class="p">:</span>
                        <span class="n">target_to_source</span><span class="p">[</span><span class="n">target_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_ids</span>
                    <span class="k">if</span> <span class="n">target_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_to_key</span><span class="p">:</span>
                        <span class="n">target_to_key</span><span class="p">[</span><span class="n">target_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_key</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_create_initial_warp_connections</span><span class="p">(</span>
                                            <span class="n">segment_pair</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;No real connection for /=====&gt;. Next case...&quot;</span><span class="p">)</span>

            <span class="c1"># CASE 4 - REGULAR ROW /=====/ ALL CASES --------------------------</span>

            <span class="c1"># look for possible targets using a guess about the chain value</span>
            <span class="n">possible_target_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">target_chain_dict</span>
                                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
                                    <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
                                    <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">connected_chains</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_target_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="n">possible_target_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_target_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># find the correct chain by using geometric distance</span>
                <span class="n">possible_target_chains</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_chain_dict</span><span class="p">[</span><span class="n">tk</span><span class="p">]</span> <span class="k">for</span> <span class="n">tk</span>
                                          <span class="ow">in</span> <span class="n">possible_target_keys</span><span class="p">]</span>
                <span class="c1"># for every chain in the possible target chains, get the</span>
                <span class="c1"># geometry and compute a sample distance</span>
                <span class="n">possible_target_chain_dists</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ptc</span> <span class="ow">in</span> <span class="n">possible_target_chains</span><span class="p">:</span>
                    <span class="c1"># retrieve possible target geometry and join into one crv</span>
                    <span class="n">ptc_geo</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ptc</span><span class="p">]</span>
                    <span class="n">ptc_geo</span> <span class="o">=</span> <span class="n">RhinoCurve</span><span class="o">.</span><span class="n">JoinCurves</span><span class="p">([</span><span class="n">pg</span><span class="o">.</span><span class="n">ToPolylineCurve</span><span class="p">()</span>
                                                     <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="n">ptc_geo</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># get a sample point and measure the distance to the</span>
                    <span class="c1"># source chain sample point</span>
                    <span class="n">ptc_spt</span> <span class="o">=</span> <span class="n">ptc_geo</span><span class="o">.</span><span class="n">PointAtNormalizedLength</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">precise</span><span class="p">:</span>
                        <span class="n">ptc_dist</span> <span class="o">=</span> <span class="n">current_chain_spt</span><span class="o">.</span><span class="n">DistanceTo</span><span class="p">(</span><span class="n">ptc_spt</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ptc_dist</span> <span class="o">=</span> <span class="n">current_chain_spt</span><span class="o">.</span><span class="n">DistanceToSquared</span><span class="p">(</span><span class="n">ptc_spt</span><span class="p">)</span>
                    <span class="c1"># append the measured distance to the list</span>
                    <span class="n">possible_target_chain_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptc_dist</span><span class="p">)</span>
                <span class="c1"># sort possible target keys using the distances</span>
                <span class="n">possible_target_chain_dists</span><span class="p">,</span> <span class="n">possible_target_keys</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                                    <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">possible_target_chain_dists</span><span class="p">,</span>
                                                <span class="n">possible_target_keys</span><span class="p">),</span>
                                            <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="n">possible_target_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># attempt warp connections if we have found a correct key</span>
            <span class="k">if</span> <span class="n">target_key</span><span class="p">:</span>
                <span class="c1"># get the guessed target chain from the chain dictionary</span>
                <span class="n">target_chain</span> <span class="o">=</span> <span class="n">target_chain_dict</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span>
                <span class="c1"># extract the ids for node retrieval</span>
                <span class="n">target_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">seg</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">target_chain</span><span class="p">])</span>
                <span class="c1"># retrieve the target nodes from the segment dictionary by id</span>
                <span class="n">target_segment_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentDict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">target_ids</span><span class="p">]</span>
                <span class="n">target_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tsn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_segment_nodes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">include_end_nodes</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">target_ids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
                    <span class="p">[</span><span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tsn</span><span class="p">]</span>

                <span class="c1"># set target first and last node (&#39;end&#39; nodes)</span>
                <span class="n">targetFirstNode</span> <span class="o">=</span> <span class="n">target_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">targetLastNode</span> <span class="o">=</span> <span class="n">target_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># check if firstNode and targetFirstNode are connected via a</span>
                <span class="c1"># &#39;warp&#39; edge to verify</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">targetFirstNode</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">firstNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="ow">and</span> <span class="n">targetLastNode</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">lastNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                    <span class="c1"># print info on verbose setting</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;/=====/ detected. Connecting &quot;</span> <span class="o">+</span>
                            <span class="s2">&quot;to segment </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_key</span><span class="p">))</span>
                    <span class="c1"># we have successfully verified our target segment and</span>
                    <span class="c1"># can create some warp edges!</span>
                    <span class="n">segment_pair</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_nodes</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">]</span>
                    <span class="n">connected_chains</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># fill mapping dictionaries</span>
                    <span class="k">if</span> <span class="n">current_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_to_target</span><span class="p">:</span>
                        <span class="n">source_to_target</span><span class="p">[</span><span class="n">current_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_ids</span>
                    <span class="k">if</span> <span class="n">current_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_to_key</span><span class="p">:</span>
                        <span class="n">source_to_key</span><span class="p">[</span><span class="n">current_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">chain_value</span>
                    <span class="k">if</span> <span class="n">target_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_to_source</span><span class="p">:</span>
                        <span class="n">target_to_source</span><span class="p">[</span><span class="n">target_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_ids</span>
                    <span class="k">if</span> <span class="n">target_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_to_key</span><span class="p">:</span>
                        <span class="n">target_to_key</span><span class="p">[</span><span class="n">target_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_key</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_create_initial_warp_connections</span><span class="p">(</span>
                                            <span class="n">segment_pair</span><span class="p">,</span>
                                            <span class="n">max_connections</span><span class="o">=</span><span class="n">max_connections</span><span class="p">,</span>
                                            <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;No real connection for /=====/. No cases match.&quot;</span><span class="p">)</span>

        <span class="c1"># INVOKE SECOND PASS FOR SOURCE ---&gt; TARGET ---------------------------</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">current_chain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source_to_target</span><span class="p">):</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;--------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;S&gt;T Current Chain: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_chain</span><span class="p">))</span>
            <span class="c1"># build a list of nodes containing all nodes in the current chain</span>
            <span class="c1"># including all &#39;end&#39; nodes</span>
            <span class="n">current_chain_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ccid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_chain</span><span class="p">):</span>
                <span class="n">current_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ccid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ccid</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="p">[</span><span class="n">current_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">SegmentDict</span><span class="p">[</span><span class="n">ccid</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">current_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">current_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">current_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>

            <span class="c1"># retrieve target chain from the source to target mapping</span>
            <span class="n">target_chain</span> <span class="o">=</span> <span class="n">source_to_target</span><span class="p">[</span><span class="n">current_chain</span><span class="p">]</span>

            <span class="n">cckey</span> <span class="o">=</span> <span class="n">source_to_key</span><span class="p">[</span><span class="n">current_chain</span><span class="p">]</span>
            <span class="n">tckey</span> <span class="o">=</span> <span class="n">target_to_key</span><span class="p">[</span><span class="n">target_chain</span><span class="p">]</span>

            <span class="c1"># build a list of nodes containing all nodes in the target chain</span>
            <span class="c1"># including all &#39;end&#39; nodes</span>
            <span class="n">target_chain_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tcid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_chain</span><span class="p">):</span>
                <span class="n">target_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tcid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">tcid</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="p">[</span><span class="n">target_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">SegmentDict</span><span class="p">[</span><span class="n">tcid</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">target_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">target_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>

            <span class="c1"># initialize start of window marker</span>
            <span class="n">start_of_window</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># loop through all nodes on the current chain</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_chain_nodes</span><span class="p">):</span>
                <span class="c1"># find out if the current node is already principally connected</span>
                <span class="n">node_connected</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># if the node is the first or the last node, it is defined as</span>
                <span class="c1"># connected per-se</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_chain_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">node_connected</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># find out if the current node is already connected to the</span>
                <span class="c1"># target chain, get node warp edges and their target nodes</span>
                <span class="n">node_warp_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_warp_edges</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">warp_edge_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">we</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">we</span> <span class="ow">in</span> <span class="n">node_warp_edges</span><span class="p">]</span>
                <span class="c1"># loop over warp edge targets to get the start of the window</span>
                <span class="k">for</span> <span class="n">wet</span> <span class="ow">in</span> <span class="n">warp_edge_targets</span><span class="p">:</span>
                    <span class="c1"># loop over target chain nodes</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">tcn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_chain_nodes</span><span class="p">):</span>
                        <span class="c1"># if a warp edge target is in the target chain,</span>
                        <span class="c1"># the node is connected and star of window for next</span>
                        <span class="c1"># node is defined</span>
                        <span class="k">if</span> <span class="n">wet</span> <span class="o">==</span> <span class="n">tcn</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">start_of_window</span> <span class="ow">or</span> <span class="n">start_of_window</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">start_of_window</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="n">node_connected</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># if the node is not connected to the target chain, we</span>
                <span class="c1"># need to find the end of the window</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node_connected</span><span class="p">:</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Node: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Start of window: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start_of_window</span><span class="p">))</span>

                    <span class="c1"># re-check start of window for &lt;.====/ case</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chain_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">start_of_window</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">target_chain_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_chain_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">start_of_window</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">start_of_window</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">end_of_window</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># loop over target chain nodes</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">tcn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_chain_nodes</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">start_of_window</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">tcn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_chain_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">end_of_window</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="c1"># get all warp edges of the current target node</span>
                            <span class="c1"># and their targets</span>
                            <span class="n">tcn_warp_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_warp_edges</span><span class="p">(</span><span class="n">tcn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                  <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">tcn_warp_edge_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">we</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">we</span>
                                                     <span class="ow">in</span> <span class="n">tcn_warp_edges</span><span class="p">]</span>
                            <span class="c1"># loop over warp edge targets</span>
                            <span class="k">for</span> <span class="n">twet</span> <span class="ow">in</span> <span class="n">tcn_warp_edge_targets</span><span class="p">:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">twet</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">cn</span>
                                             <span class="ow">in</span> <span class="n">current_chain_nodes</span><span class="p">]):</span>
                                    <span class="n">end_of_window</span> <span class="o">=</span> <span class="n">n</span>
                                    <span class="k">break</span>
                        <span class="k">if</span> <span class="n">end_of_window</span> <span class="ow">and</span> <span class="n">end_of_window</span> <span class="o">&gt;</span> <span class="n">start_of_window</span><span class="p">:</span>
                            <span class="k">break</span>

                    <span class="c1"># re-check end of window for /====.&gt; case</span>
                    <span class="k">if</span> <span class="n">end_of_window</span><span class="p">:</span>
                        <span class="n">tcn_we</span> <span class="o">=</span> <span class="n">target_chain_nodes</span><span class="p">[</span><span class="n">end_of_window</span><span class="p">]</span>
                        <span class="n">ccn_end</span> <span class="o">=</span> <span class="n">current_chain_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">ccn_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_chain_nodes</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">tcn_we</span> <span class="o">==</span> <span class="n">ccn_end</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="n">ccn_len</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                            <span class="n">end_of_window</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">end_of_window</span> <span class="o">&lt;</span> <span class="n">start_of_window</span><span class="p">:</span>
                        <span class="n">start_of_window</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">end_of_window</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="c1"># if we have a valid window, set the target nodes</span>
                    <span class="k">if</span> <span class="n">start_of_window</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">end_of_window</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">end_of_window</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chain_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">window</span> <span class="o">=</span> <span class="n">target_chain_nodes</span><span class="p">[</span><span class="n">start_of_window</span><span class="p">:]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">window</span> <span class="o">=</span> <span class="n">target_chain_nodes</span><span class="p">[</span><span class="n">start_of_window</span><span class="p">:</span>
                                                        <span class="n">end_of_window</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;End of window: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end_of_window</span><span class="p">))</span>

                        <span class="c1"># execute connection to target</span>
                        <span class="k">if</span> <span class="n">cckey</span> <span class="o">&lt;=</span> <span class="n">tckey</span><span class="p">:</span>
                            <span class="n">rev</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rev</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Connecting chain </span><span class="si">{}</span><span class="s2"> to chain </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="n">cckey</span><span class="p">,</span>
                                                                    <span class="n">tckey</span><span class="p">))</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_create_second_pass_warp_connection</span><span class="p">(</span>
                                                        <span class="n">current_chain_nodes</span><span class="p">,</span>
                                                        <span class="n">k</span><span class="p">,</span>
                                                        <span class="n">window</span><span class="p">,</span>
                                                        <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                        <span class="n">reverse</span><span class="o">=</span><span class="n">rev</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># print info on verbose setting</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;No valid window for current chain!&quot;</span><span class="p">)</span>

        <span class="c1"># INVOKE SECOND PASS FOR TARGET ---&gt; SOURCE ---------------------------</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">current_chain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_to_source</span><span class="p">):</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;--------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;T&gt;S Current Chain: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_chain</span><span class="p">))</span>

            <span class="c1"># build a list of nodes containing all nodes in the current chain</span>
            <span class="c1"># including all &#39;end&#39; nodes</span>
            <span class="n">current_chain_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ccid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_chain</span><span class="p">):</span>
                <span class="n">current_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ccid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ccid</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="p">[</span><span class="n">current_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">SegmentDict</span><span class="p">[</span><span class="n">ccid</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">current_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">current_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">current_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>

            <span class="c1"># retrieve target chain from the source to target mapping</span>
            <span class="n">target_chain</span> <span class="o">=</span> <span class="n">target_to_source</span><span class="p">[</span><span class="n">current_chain</span><span class="p">]</span>

            <span class="n">cckey</span> <span class="o">=</span> <span class="n">target_to_key</span><span class="p">[</span><span class="n">current_chain</span><span class="p">]</span>
            <span class="n">tckey</span> <span class="o">=</span> <span class="n">source_to_key</span><span class="p">[</span><span class="n">target_chain</span><span class="p">]</span>

            <span class="c1"># build a list of nodes containing all nodes in the target chain</span>
            <span class="c1"># including all &#39;end&#39; nodes</span>
            <span class="n">target_chain_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tcid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_chain</span><span class="p">):</span>
                <span class="n">target_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tcid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">tcid</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="p">[</span><span class="n">target_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">SegmentDict</span><span class="p">[</span><span class="n">tcid</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">target_chain_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">target_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>

            <span class="c1"># initialize start of window marker</span>
            <span class="n">start_of_window</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># loop through all nodes on the current chain</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_chain_nodes</span><span class="p">):</span>
                <span class="c1"># find out if the current node is already principally connected</span>
                <span class="n">node_connected</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_chain_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">node_connected</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># find out if the current node is already connected to the</span>
                <span class="c1"># target chain</span>
                <span class="n">node_warp_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_warp_edges</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">warp_edge_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">we</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">we</span> <span class="ow">in</span> <span class="n">node_warp_edges</span><span class="p">]</span>
                <span class="c1"># loop over weft edge targets</span>
                <span class="k">for</span> <span class="n">wet</span> <span class="ow">in</span> <span class="n">warp_edge_targets</span><span class="p">:</span>
                    <span class="c1"># if warp edge target  is in target chain nodes, node</span>
                    <span class="c1"># is connected and the start of our window for the next</span>
                    <span class="c1"># node</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">tcn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_chain_nodes</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">wet</span> <span class="o">==</span> <span class="n">tcn</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">start_of_window</span> <span class="ow">or</span> <span class="n">start_of_window</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">start_of_window</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="n">node_connected</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># if the node is not connected to the target chain, we</span>
                <span class="c1"># need to find the end of the window</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node_connected</span><span class="p">:</span>
                    <span class="c1"># print info on verbose output</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Node: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Start of window: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start_of_window</span><span class="p">))</span>

                    <span class="c1"># re-check start of window for &lt;.====/ case</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chain_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">start_of_window</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">target_chain_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_chain_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">start_of_window</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">start_of_window</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">end_of_window</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># loop over target chain nodes</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">tcn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_chain_nodes</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">start_of_window</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">tcn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_chain_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">end_of_window</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="c1"># get all warp edges of the current target node and</span>
                            <span class="c1"># their targets</span>
                            <span class="n">tcn_warp_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_warp_edges</span><span class="p">(</span><span class="n">tcn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                  <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">tcn_warp_edge_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">we</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">we</span>
                                                     <span class="ow">in</span> <span class="n">tcn_warp_edges</span><span class="p">]</span>
                            <span class="c1"># loop over warp edge targets of current target</span>
                            <span class="c1"># node</span>
                            <span class="k">for</span> <span class="n">twet</span> <span class="ow">in</span> <span class="n">tcn_warp_edge_targets</span><span class="p">:</span>
                                <span class="c1"># if warp edge target is in current chain,</span>
                                <span class="c1"># it is the end of the window</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">twet</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">cn</span>
                                             <span class="ow">in</span> <span class="n">current_chain_nodes</span><span class="p">]):</span>
                                    <span class="n">end_of_window</span> <span class="o">=</span> <span class="n">n</span>
                                    <span class="k">break</span>
                        <span class="k">if</span> <span class="n">end_of_window</span> <span class="ow">and</span> <span class="n">end_of_window</span> <span class="o">&gt;</span> <span class="n">start_of_window</span><span class="p">:</span>
                            <span class="k">break</span>

                    <span class="c1"># re-check end of window for /====.&gt; case</span>
                    <span class="k">if</span> <span class="n">end_of_window</span><span class="p">:</span>
                        <span class="n">tcn_we</span> <span class="o">=</span> <span class="n">target_chain_nodes</span><span class="p">[</span><span class="n">end_of_window</span><span class="p">]</span>
                        <span class="n">ccn_end</span> <span class="o">=</span> <span class="n">current_chain_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">ccn_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_chain_nodes</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">tcn_we</span> <span class="o">==</span> <span class="n">ccn_end</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="n">ccn_len</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                            <span class="n">end_of_window</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">end_of_window</span> <span class="o">&lt;</span> <span class="n">start_of_window</span><span class="p">:</span>
                        <span class="n">start_of_window</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">end_of_window</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="c1"># if there is a valid window, set the target chain nodes</span>
                    <span class="k">if</span> <span class="n">start_of_window</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">end_of_window</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">end_of_window</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chain_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">window</span> <span class="o">=</span> <span class="n">target_chain_nodes</span><span class="p">[</span><span class="n">start_of_window</span><span class="p">:]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">window</span> <span class="o">=</span> <span class="n">target_chain_nodes</span><span class="p">[</span><span class="n">start_of_window</span><span class="p">:</span>
                                                        <span class="n">end_of_window</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># print info on verbose output</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;End of window: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end_of_window</span><span class="p">))</span>

                        <span class="c1"># execute connection</span>
                        <span class="k">if</span> <span class="n">cckey</span> <span class="o">&lt;</span> <span class="n">tckey</span><span class="p">:</span>
                            <span class="n">rev</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rev</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;Connecting chain </span><span class="si">{}</span><span class="s2"> to chain </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                        <span class="n">cckey</span><span class="p">,</span>
                                                                        <span class="n">tckey</span><span class="p">))</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_create_second_pass_warp_connection</span><span class="p">(</span>
                                                        <span class="n">current_chain_nodes</span><span class="p">,</span>
                                                        <span class="n">k</span><span class="p">,</span>
                                                        <span class="n">window</span><span class="p">,</span>
                                                        <span class="n">precise</span><span class="o">=</span><span class="n">precise</span><span class="p">,</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                        <span class="n">reverse</span><span class="o">=</span><span class="n">rev</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v_print</span><span class="p">(</span><span class="s2">&quot;No valid window for current chain!&quot;</span><span class="p">)</span></div>

    <span class="c1"># FIND FACES OF NETWORK ---------------------------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.to_KnitDiNetwork"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.to_KnitDiNetwork">[docs]</a>    <span class="k">def</span> <span class="nf">to_KnitDiNetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs and returns a directed KnitDiNetwork based on this network</span>
<span class="sd">        by duplicating all edges so that [u -&gt; v] and [v -&gt; u] for every</span>
<span class="sd">        edge [u - v] in this undirected network.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        directed_network : :class:`KnitDiNetwork`</span>
<span class="sd">            The directed representation of this network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create a directed network with duplicate edges in opposing directions</span>
        <span class="n">dirnet</span> <span class="o">=</span> <span class="n">KnitDiNetwork</span><span class="p">()</span>

        <span class="n">dirnet</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">dirnet</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">dirnet</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_iter</span><span class="p">()</span>
                              <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">dirnet</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">dirnet</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span>
        <span class="n">dirnet</span><span class="o">.</span><span class="n">mapping_network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_network</span>

        <span class="k">return</span> <span class="n">dirnet</span></div>

<div class="viewcode-block" id="KnitNetwork.find_cycles"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.find_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">find_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the cycles (faces) of this network by utilizing a wall-follower</span>
<span class="sd">        mechanism.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : int, optional</span>
<span class="sd">            Determines how the neighbors of each node are sorted when finding</span>
<span class="sd">            cycles for the network.</span>
<span class="sd">            ``-1`` equals to using the world XY plane.</span>

<span class="sd">            ``0`` equals to using a plane normal to the origin nodes closest</span>
<span class="sd">            point on the reference geometry.</span>

<span class="sd">            ``1`` equals to using a plane normal to the average of the origin</span>
<span class="sd">            and neighbor nodes&#39; closest points on the reference geometry.</span>

<span class="sd">            ``2`` equals to using an average plane between a plane fit to the</span>
<span class="sd">            origin and its neighbor nodes and a plane normal to the origin</span>
<span class="sd">            nodes closest point on the reference geometry.</span>

<span class="sd">            Defaults to ``-1``.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        Modes other than ``-1`` are only possible if this network has an</span>
<span class="sd">        underlying reference geometry in form of a Mesh or NurbsSurface. The</span>
<span class="sd">        reference geometry should be assigned when initializing the network by</span>
<span class="sd">        assigning the geometry to the &quot;reference_geometry&quot; attribute of the</span>
<span class="sd">        network.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Based on an implementation inside the COMPAS framework.</span>
<span class="sd">        For more info see [16]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_KnitDiNetwork</span><span class="p">()</span><span class="o">.</span><span class="n">find_cycles</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="KnitNetwork.create_mesh"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.create_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">create_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_valence</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a mesh from this network by finding cycles and using them as</span>
<span class="sd">        mesh faces.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : int, optional</span>
<span class="sd">            Determines how the neighbors of each node are sorted when finding</span>
<span class="sd">            cycles for the network.</span>

<span class="sd">            ``-1`` equals to using the world XY plane.</span>

<span class="sd">            ``0`` equals to using a plane normal to the origin nodes closest</span>
<span class="sd">            point on the reference geometry.</span>

<span class="sd">            ``1`` equals to using a plane normal to the average of the origin</span>
<span class="sd">            and neighbor nodes&#39; closest points on the reference geometry.</span>

<span class="sd">            ``2`` equals to using an average plane between a plane fit to the</span>
<span class="sd">            origin and its neighbor nodes and a plane normal to the origin</span>
<span class="sd">            nodes closest point on the reference geometry.</span>

<span class="sd">            Defaults to ``-1``.</span>

<span class="sd">        max_valence : int, optional</span>
<span class="sd">            Sets the maximum edge valence of the faces. If this is set to &gt; 4,</span>
<span class="sd">            n-gon faces (more than 4 edges) are allowed. Otherwise, their</span>
<span class="sd">            cycles are treated as invalid and will be ignored.</span>

<span class="sd">            Defaults to ``4``.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        Modes other than ``-1`` are only possible if this network has an</span>
<span class="sd">        underlying reference geometry in form of a Mesh or NurbsSurface. The</span>
<span class="sd">        reference geometry should be assigned when initializing the network by</span>
<span class="sd">        assigning the geometry to the &quot;reference_geometry&quot; attribute of the</span>
<span class="sd">        network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_KnitDiNetwork</span><span class="p">()</span><span class="o">.</span><span class="n">create_mesh</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                                                   <span class="n">max_valence</span><span class="o">=</span><span class="n">max_valence</span><span class="p">)</span></div>

    <span class="c1"># DUALITY -----------------------------------------------------------------</span>

<div class="viewcode-block" id="KnitNetwork.create_dual"><a class="viewcode-back" href="../../cockatoo.html#cockatoo.KnitNetwork.create_dual">[docs]</a>    <span class="k">def</span> <span class="nf">create_dual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">merge_adj_creases</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">mend_trailing_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the dual of this KnitNetwork while translating current edge</span>
<span class="sd">        attributes to the edges of the dual network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : int, optional</span>
<span class="sd">            Determines how the neighbors of each node are sorted when finding</span>
<span class="sd">            cycles for the network.</span>

<span class="sd">            ``-1`` equals to using the world XY plane.</span>

<span class="sd">            ``0`` equals to using a plane normal to the origin nodes closest</span>
<span class="sd">            point on the reference geometry.</span>

<span class="sd">            ``1`` equals to using a plane normal to the average of the origin</span>
<span class="sd">            and neighbor nodes&#39; closest points on the reference geometry.</span>

<span class="sd">            ``2`` equals to using an average plane between a plane fit to the</span>
<span class="sd">            origin and its neighbor nodes and a plane normal to the origin</span>
<span class="sd">            nodes closest point on the reference geometry.</span>

<span class="sd">            Defaults to ``-1``.</span>

<span class="sd">        merge_adj_creases : bool, optional</span>
<span class="sd">            If ``True``, will merge adjacent &#39;increase&#39; and &#39;decrease&#39; nodes</span>
<span class="sd">            connected by a &#39;weft&#39; edge into a single node. This effectively</span>
<span class="sd">            simplifies the pattern, as a decrease is unneccessary to perform</span>
<span class="sd">            if an increase is right beside it - both nodes can be replaced by a</span>
<span class="sd">            single regular node (stitch).</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        mend_trailing_rows : bool, optional</span>
<span class="sd">            If ``True``, will attempt to mend trailing rows by reconnecting</span>
<span class="sd">            nodes.</span>

<span class="sd">            Defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dual_network : :class:`KnitDiNetwork`</span>
<span class="sd">            The dual network of this KnitNetwork.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        Modes other than -1 (default) are only possible if this network has an</span>
<span class="sd">        underlying reference geometry in form of a Mesh or NurbsSurface. The</span>
<span class="sd">        reference geometry  should be assigned when initializing the network by</span>
<span class="sd">        assigning the geometry to the &#39;reference_geometry&#39; attribute of the</span>
<span class="sd">        network.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Closely resembles the implementation described in *Automated Generation</span>
<span class="sd">        of Knit Patterns for Non-developable Surfaces* [1]_. Also see</span>
<span class="sd">        *KnitCrete - Stay-in-place knitted formworks for complex concrete</span>
<span class="sd">        structures* [2]_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first find the cycles of this network</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_cycles</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="c1"># get node data for all nodes once</span>
        <span class="n">node_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">()}</span>

        <span class="c1"># create new directed KnitDiNetwork for dual network</span>
        <span class="n">DualNetwork</span> <span class="o">=</span> <span class="n">KnitDiNetwork</span><span class="p">(</span>
                        <span class="n">reference_geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;reference_geometry&quot;</span><span class="p">])</span>

        <span class="c1"># create mapping dict for edges to adjacent cycles</span>
        <span class="n">edge_to_cycle</span> <span class="o">=</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">()}</span>
        <span class="n">edge_to_cycle</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">()})</span>

        <span class="c1"># CREATE NODES OF DUAL ------------------------------------------------</span>

        <span class="c1"># for each cycle, find the centroid node</span>
        <span class="k">for</span> <span class="n">ckey</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cycles</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="n">cycles</span><span class="p">[</span><span class="n">ckey</span><span class="p">]</span>
            <span class="n">clen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>

            <span class="c1"># skip invalid cycles (ngons and self-loops)</span>
            <span class="k">if</span> <span class="n">clen</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">clen</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># loop over cycle edges and fill mapping dicts</span>
            <span class="n">closed_cycle</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[:]</span>
            <span class="n">closed_cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pairwise</span><span class="p">(</span><span class="n">closed_cycle</span><span class="p">):</span>
                <span class="n">edge_to_cycle</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ckey</span>

            <span class="c1"># get coords of cycle nodes</span>
            <span class="n">cycle_coords</span> <span class="o">=</span> <span class="p">[[</span><span class="n">node_data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
                             <span class="n">node_data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">],</span>
                             <span class="n">node_data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">]</span>

            <span class="c1"># compute centroid</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cycle_coords</span><span class="p">)</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span> <span class="o">/</span> <span class="n">clen</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cy</span><span class="p">)</span> <span class="o">/</span> <span class="n">clen</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cz</span><span class="p">)</span> <span class="o">/</span> <span class="n">clen</span><span class="p">]</span>
            <span class="n">centroid_pt</span> <span class="o">=</span> <span class="n">RhinoPoint3d</span><span class="p">(</span><span class="o">*</span><span class="n">centroid</span><span class="p">)</span>

            <span class="c1"># get node &#39;leaf&#39; attributes</span>
            <span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node_data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;leaf&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">]</span>

            <span class="c1"># get node &#39;color&#39; attributes. only if all colors of the cycle</span>
            <span class="c1"># match, the color attribute will be set!</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">):</span>
                <span class="n">cycle_color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cycle_color</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># add node to dual network</span>
            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_from_point3d</span><span class="p">(</span><span class="n">ckey</span><span class="p">,</span>
                                          <span class="n">centroid_pt</span><span class="p">,</span>
                                          <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">leaf</span><span class="o">=</span><span class="n">is_leaf</span><span class="p">,</span>
                                          <span class="n">start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">segment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">increase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">decrease</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">color</span><span class="o">=</span><span class="n">cycle_color</span><span class="p">)</span>

        <span class="c1"># CREATE EDGES IN DUAL ------------------------------------------------</span>

        <span class="c1"># loop over original edges and create corresponding edges in dual</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_geometry_direction</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">cycle_a</span> <span class="o">=</span> <span class="n">edge_to_cycle</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span>
            <span class="n">cycle_b</span> <span class="o">=</span> <span class="n">edge_to_cycle</span><span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">cycle_a</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cycle_b</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_a</span><span class="p">,</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cycle_a</span><span class="p">])</span>
                <span class="n">node_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_b</span><span class="p">,</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cycle_b</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;warp&quot;</span><span class="p">]:</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">node_b</span><span class="p">,</span> <span class="n">node_a</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;weft&quot;</span><span class="p">]:</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">node_a</span><span class="p">,</span> <span class="n">node_b</span><span class="p">)</span>

        <span class="c1"># SET ATTRIBUTES OF DUAL NODES ----------------------------------------</span>

        <span class="c1"># loop over all nodes of the network and set crease and end attributes</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">():</span>
            <span class="n">node_data</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

            <span class="n">warp_in</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_warp_edges_in</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">warp_out</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_warp_edges_out</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">weft_in</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_weft_edges_in</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">weft_out</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_weft_edges_out</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="n">warplen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">warp_in</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">warp_out</span><span class="p">)</span>
            <span class="n">weftlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weft_in</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">weft_out</span><span class="p">)</span>

            <span class="c1"># 2 warp edges and 1 weft edge  &gt;&gt; end</span>
            <span class="k">if</span> <span class="n">warplen</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">weftlen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">weft_out</span><span class="p">:</span>
                    <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># 1 warp edge and 1 weft edge   &gt;&gt; end and increase / decrease</span>
            <span class="k">elif</span> <span class="n">warplen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">weftlen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">weft_out</span><span class="p">:</span>
                    <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">warp_out</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;leaf&quot;</span><span class="p">]:</span>
                    <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;increase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">warp_in</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;leaf&quot;</span><span class="p">]:</span>
                    <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;decrease&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># 2 warp edges and 0 weft edges &gt;&gt; end</span>
            <span class="k">elif</span> <span class="n">warplen</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">weftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># 1 warp edge and 0 weft edges  &gt;&gt; end</span>
            <span class="k">elif</span> <span class="n">warplen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">weftlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># 0 warp edges and 1 weft edge  &gt;&gt; end</span>
            <span class="k">elif</span> <span class="n">warplen</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">weftlen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">weft_out</span><span class="p">:</span>
                    <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># 1 warp edge and 2 weft edges  &gt;&gt; increase or decrease</span>
            <span class="k">elif</span> <span class="n">warplen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">weftlen</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;leaf&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">warp_out</span><span class="p">:</span>
                        <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;increase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="n">warp_in</span><span class="p">:</span>
                        <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;decrease&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># MERGE ADJACENT INCREASES/DECREASES ----------------------------------</span>

        <span class="k">if</span> <span class="n">merge_adj_creases</span><span class="p">:</span>
            <span class="n">increase_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">inc</span> <span class="k">for</span> <span class="n">inc</span> <span class="ow">in</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                              <span class="k">if</span> <span class="n">inc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;increase&quot;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">increase</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">increase_nodes</span><span class="p">:</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">increase</span><span class="p">)</span>
                <span class="n">suc</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">increase</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pred</span> <span class="k">if</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s2">&quot;decrease&quot;</span><span class="p">]]</span>
                <span class="n">suc</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">suc</span> <span class="k">if</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s2">&quot;decrease&quot;</span><span class="p">]]</span>
                <span class="c1"># merge only with pred or with suc but not both</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="n">DualNetwork</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">increase</span><span class="p">][</span><span class="s2">&quot;weft&quot;</span><span class="p">]):</span>
                    <span class="c1"># merge nodes, edge is pred, increase</span>
                    <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">pd</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">pred</span><span class="p">]</span>
                    <span class="c1"># remove the connecting edge</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">increase</span><span class="p">)</span>
                    <span class="c1"># get the points of the nodes</span>
                    <span class="n">increase_pt</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>
                    <span class="n">pred_pt</span> <span class="o">=</span> <span class="n">pd</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>
                    <span class="c1"># compute the new merged point</span>
                    <span class="n">new_vec</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="p">(</span><span class="n">increase_pt</span> <span class="o">-</span> <span class="n">pred_pt</span><span class="p">)</span>
                    <span class="n">new_pt</span> <span class="o">=</span> <span class="n">pred_pt</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_vec</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
                    <span class="c1"># replace the increase with the new pt and invert the</span>
                    <span class="c1"># increase attribute</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span><span class="o">.</span><span class="n">X</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span><span class="o">.</span><span class="n">Y</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span><span class="o">.</span><span class="n">Z</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;increase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># edit the edges of the increase</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                                            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">],</span>
                                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                    <span class="c1"># edit edges of decrease</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">in_edges_iter</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;warp&quot;</span><span class="p">]:</span>
                            <span class="n">fromNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                            <span class="n">toNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">fromNode</span><span class="p">,</span> <span class="n">toNode</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;weft&quot;</span><span class="p">]:</span>
                            <span class="n">fromNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                            <span class="n">toNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">fromNode</span><span class="p">,</span> <span class="n">toNode</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pred</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">suc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="n">DualNetwork</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">increase</span><span class="p">][</span><span class="n">suc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;weft&quot;</span><span class="p">]):</span>
                    <span class="c1"># merge nodes, edge is increase, suc</span>
                    <span class="n">suc</span> <span class="o">=</span> <span class="n">suc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">sd</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">suc</span><span class="p">]</span>
                    <span class="c1"># remove the connecting edge</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">suc</span><span class="p">)</span>
                    <span class="c1"># get the points of the nodes</span>
                    <span class="n">increase_pt</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>
                    <span class="n">suc_pt</span> <span class="o">=</span> <span class="n">sd</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span>
                    <span class="c1"># compute the new merged point</span>
                    <span class="n">new_vec</span> <span class="o">=</span> <span class="n">RhinoVector3d</span><span class="p">(</span><span class="n">suc_pt</span> <span class="o">-</span> <span class="n">increase_pt</span><span class="p">)</span>
                    <span class="n">new_pt</span> <span class="o">=</span> <span class="n">increase_pt</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_vec</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
                    <span class="c1"># replace the increase with the new pt and invert the</span>
                    <span class="c1"># increase attribute</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span><span class="o">.</span><span class="n">X</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span><span class="o">.</span><span class="n">Y</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span><span class="o">.</span><span class="n">Z</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;increase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># edit the edges of the increase</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                                            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">],</span>
                                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">in_edges_iter</span><span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;geo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RhinoLine</span><span class="p">(</span>
                                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;geo&quot;</span><span class="p">],</span>
                                            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;geo&quot;</span><span class="p">])</span>
                    <span class="c1"># edit incoming edges of decrease</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">in_edges_iter</span><span class="p">(</span><span class="n">suc</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;warp&quot;</span><span class="p">]:</span>
                            <span class="n">fromNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                            <span class="n">toNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">fromNode</span><span class="p">,</span> <span class="n">toNode</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;weft&quot;</span><span class="p">]:</span>
                            <span class="n">fromNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                            <span class="n">toNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">fromNode</span><span class="p">,</span> <span class="n">toNode</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># edit outgoing edges of decrease</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">suc</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;warp&quot;</span><span class="p">]:</span>
                            <span class="n">fromNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                            <span class="n">toNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">fromNode</span><span class="p">,</span> <span class="n">toNode</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;weft&quot;</span><span class="p">]:</span>
                            <span class="n">fromNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                            <span class="n">toNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_weft_edge</span><span class="p">(</span><span class="n">fromNode</span><span class="p">,</span> <span class="n">toNode</span><span class="p">)</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">suc</span><span class="p">)</span>

        <span class="c1"># ATTEMPT TO MEND TRAILING ROWS ---------------------------------------</span>

        <span class="k">if</span> <span class="n">mend_trailing_rows</span><span class="p">:</span>

            <span class="c1"># TODO: find a safer / more robust implementation attempt!</span>
            <span class="n">errMsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;This option is not satisfyingly implemented for this &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;method, yet. Therefore, it is deactivated for now.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">errMsg</span><span class="p">)</span>

            <span class="c1"># get all nodes which are &#39;leaf&#39; and &#39;end&#39; (right side)</span>
            <span class="c1"># and all nodes which are &#39;leaf&#39; and &#39;start&#39; (left side)</span>
            <span class="n">trailing</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span>
                              <span class="n">DualNetwork</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                              <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;leaf&quot;</span><span class="p">]</span>
                              <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">trailing_left</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trailing</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;start&quot;</span><span class="p">]])</span>
            <span class="n">trailing_right</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trailing</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;start&quot;</span><span class="p">]])</span>

            <span class="c1"># from the trailing left nodes...</span>
            <span class="c1"># travel one outgoing &#39;weft&#39;</span>
            <span class="c1"># from there travel one incoming &#39;warp&#39;</span>
            <span class="c1"># if the resulting node is &#39;start&#39;, &#39;end&#39; and has 3 edges in total</span>
            <span class="c1"># &gt;&gt; take its outgoing &#39;warp&#39; edge (we already traveled that so</span>
            <span class="c1">#    we should already have it)</span>
            <span class="c1"># &gt;&gt; connect it to the trailing left node</span>
            <span class="c1"># &gt;&gt; remove the &#39;leaf&#39; attribute from the trailing node as it is no</span>
            <span class="c1">#    longer trailing</span>
            <span class="c1"># &gt;&gt; add the &#39;increase&#39; attribute to the previous target of the</span>
            <span class="c1">#    &#39;warp&#39; edge</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">trailing_left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># pop an item from the deque</span>
                <span class="n">trail</span> <span class="o">=</span> <span class="n">trailing_left</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="c1"># travel one outgoing &#39;weft&#39; edge</span>
                <span class="n">weft_out</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_weft_edges_out</span><span class="p">(</span><span class="n">trail</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">weft_out</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">weft_out</span> <span class="o">=</span> <span class="n">weft_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># check the target of the &#39;weft&#39; edge for incoming &#39;warp&#39;</span>
                <span class="n">warp_in</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_warp_edges_in</span><span class="p">(</span>
                                                        <span class="n">weft_out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                        <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">warp_out</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_warp_edges_out</span><span class="p">(</span>
                                                        <span class="n">weft_out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                        <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">warp_in</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">warp_in</span> <span class="o">=</span> <span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">nce</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DualNetwork</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">nce</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DualNetwork</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="c1"># if this condition holds, we have a trailing increase</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">nce</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="c1"># remove found &#39;warp&#39; edge</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">warp_in</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># assign &#39;increase&#39; attribute to former &#39;warp&#39; edge target</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;increase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># connect candidate to trail with new &#39;warp&#39; edge</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">trail</span><span class="p">)</span>
                    <span class="c1"># remove &#39;leaf&#39; attribute of former trail</span>
                    <span class="n">trail</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;leaf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">warp_out</span><span class="p">:</span>
                        <span class="n">warp_out</span> <span class="o">=</span> <span class="n">warp_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                        <span class="n">nce</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DualNetwork</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">nce</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DualNetwork</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="c1"># if this condition holds, we have a trailing decrease</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>
                                <span class="ow">and</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
                                <span class="ow">and</span> <span class="n">nce</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                            <span class="c1"># remove found &#39;warp&#39; edge</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="c1"># assign &#39;decrease&#39; attribute to former &#39;warp&#39;</span>
                            <span class="c1"># edge source</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;decrease&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="c1"># connect former trail to candidate with new</span>
                            <span class="c1"># &#39;warp&#39; edge</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">trail</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
                            <span class="c1"># remove &#39;leaf&#39; attribute of former trail</span>
                            <span class="n">trail</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;leaf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">trailing_right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># pop an item from the deque</span>
                <span class="n">trail</span> <span class="o">=</span> <span class="n">trailing_right</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="c1"># travel one incoming &#39;weft&#39; edge</span>
                <span class="n">weft_in</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_weft_edges_in</span><span class="p">(</span><span class="n">trail</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">weft_in</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">weft_in</span> <span class="o">=</span> <span class="n">weft_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># check the target of the &#39;weft&#39; edge for incoming &#39;warp&#39;</span>
                <span class="n">warp_in</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_warp_edges_in</span><span class="p">(</span><span class="n">weft_in</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">warp_out</span> <span class="o">=</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node_warp_edges_out</span><span class="p">(</span><span class="n">weft_in</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                           <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">warp_in</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">warp_in</span> <span class="o">=</span> <span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">nce</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DualNetwork</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">nce</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DualNetwork</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="c1"># if this condition holds, we have a trailing increase</span>
                <span class="k">if</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">nce</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># remove found &#39;warp&#39; edge</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">warp_in</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># assign &#39;increase&#39; attribute to former &#39;warp&#39; edge target</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">warp_in</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;increase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># connect candidate to trail with new &#39;warp&#39; edge</span>
                    <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">trail</span><span class="p">)</span>
                    <span class="c1"># remove &#39;leaf&#39; attribute of former trail</span>
                    <span class="n">trail</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;leaf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">warp_out</span><span class="p">:</span>
                        <span class="n">warp_out</span> <span class="o">=</span> <span class="n">warp_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                        <span class="n">nce</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DualNetwork</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">nce</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DualNetwork</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="c1"># if this condition holds, we have a trailing decrease</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>
                                <span class="ow">and</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
                                <span class="ow">and</span> <span class="n">nce</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                            <span class="c1"># remove found &#39;warp&#39; edge</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">warp_out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="c1"># assign &#39;decrease&#39; attribute to former &#39;warp&#39;</span>
                            <span class="c1"># edge source</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">warp_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;decrease&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="c1"># connect former trail to candidate with new</span>
                            <span class="c1"># &#39;warp&#39; edge</span>
                            <span class="n">DualNetwork</span><span class="o">.</span><span class="n">create_warp_edge</span><span class="p">(</span><span class="n">trail</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
                            <span class="c1"># remove &#39;leaf&#39; attribute of former trail</span>
                            <span class="n">trail</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;leaf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">DualNetwork</span></div></div>

<span class="c1"># MAIN ------------------------------------------------------------------------</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Max Eschenbach.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1.1.0-alpha',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>
      <script type="text/javascript" src="../../_static/jquery.fancybox.min.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
  <script type="text/javascript">
    $(function(){
      $('.image-reference').fancybox();
    })
  </script>

</body>
</html>